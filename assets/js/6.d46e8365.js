(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{389:function(_,v,t){_.exports=t.p+"assets/img/TCP-Three-Handshakes-2.02561602.png"},390:function(_,v,t){_.exports=t.p+"assets/img/TCP-Three-Handshakes.20c8cfa8.png"},391:function(_,v,t){_.exports=t.p+"assets/img/TCP-Four-Waves.3de448aa.png"},392:function(_,v,t){_.exports=t.p+"assets/img/The-Same-Time-Create-TCP-Connect.8de795e0.jpg"},536:function(_,v,t){"use strict";t.r(v);var e=t(46),s=Object(e.a)({},(function(){var _=this,v=_.$createElement,e=_._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[e("h1",{attrs:{id:"tcp"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tcp"}},[_._v("#")]),_._v(" TCP")]),_._v(" "),e("p",[_._v("前置词汇：")]),_._v(" "),e("ul",[e("li",[e("p",[e("strong",[_._v("SYN")]),_._v("："),e("strong",[_._v("同步序列编号")]),_._v("（"),e("strong",[_._v("Synchronize Sequence Numbers")]),_._v("）。是TCP/IP建立连接时使用的握手信号。在客户机和服务器之间建立正常的TCP网络连接时，客户机首先发出一个SYN消息，服务器使用SYN+ACK应答表示接收到了这个消息，最后客户机再以ACK消息响应。这样在客户机和服务器之间才能建立起可靠的TCP连接，数据才可以在客户机和服务器之间传递。")]),_._v(" "),e("p",[_._v("TCP连接的第一个包，非常小的一种数据包。SYN 攻击包括大量此类的包，由于这些包看上去来自实际不存在的站点，因此无法有效进行处理。每个机器的欺骗包都要花几秒钟进行尝试方可放弃提供正常响应。")]),_._v(" "),e("p",[_._v("凡是需要对端确认的，一定消耗TCP报文的序列号。")])]),_._v(" "),e("li",[e("p",[e("strong",[_._v("ACK")]),_._v("："),e("strong",[_._v("确认字符")]),_._v("("),e("strong",[_._v("Acknowledge character")]),_._v("）。在数据通信中，接收站发给发送站的一种传输类控制字符。表示发来的数据已确认接收无误。")]),_._v(" "),e("p",[_._v("在TCP/IP协议中，如果接收方成功的接收到数据，那么会回复一个ACK数据。通常ACK信号有自己固定的格式,长度大小,由接收方回复给发送方。")])]),_._v(" "),e("li",[e("p",[e("strong",[_._v("seq")]),_._v("、"),e("strong",[_._v("ack")]),_._v("：seq是序列号，这是为了连接以后传送数据用的，ack是对收到百的数据包的确认，值是等待接收的数据包的序列号。\n在第一次消息发送中，A随机选取一个序列号作为自己的初始序号发送给B；第二次消息B使用度ack对A的数据包进行确认，因为已经收到了序列号为x的数据包，准备接收序列号为x+1的包，所以ack=x+1，同时B告诉A自己的初始序列号，就是seq=y；第三回条消息A告诉B收到了B的确认消息并准备建立连接，A自己此条消息的序列号是x+1，所以seq=x+1，而ack=y+1是表示A正准备接收B序列号为答y+1的数据包。")]),_._v(" "),e("p",[e("strong",[_._v("seq是数据包本身的序列号；ack是期望对方继续发送的那个数据包的序列号。")])])])]),_._v(" "),e("h2",{attrs:{id:"简述"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#简述"}},[_._v("#")]),_._v(" 简述")]),_._v(" "),e("p",[_._v("简单的讲，通常发起请求，是http协议（高级的应用层协议），其底层是TCP。\nTCP的协议是说，客户端（请求方，主动发起）、服务端（响应方）如何连接的。\n三次握手的举例：员工投简历，公司发邮件约面试，员工回复准时赴约。\n三次握手的深入举例：\n客户端有基本数据x，服务端有基本数据y\n1、客户端：x 发送\n2、服务端：x + 1回去，再带上自己的y\n3、客户端：y + 1回去\nps: 细品“回去”，+1就是告诉对方，我肯定知道你给我的是啥\n三次握手的实际情况：\n1、客户端：SYN=1,seq=x\n2、服务端：SYN=1,ACK=1,seq=y,ack=x+1\n3、客户端：ACK=1,seq=x+1,ack=y+1")]),_._v(" "),e("h2",{attrs:{id:"简述2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#简述2"}},[_._v("#")]),_._v(" 简述2")]),_._v(" "),e("p",[e("code",[_._v("SEQ")]),_._v("，序列号，表示每次传输中字节的偏移量 "),e("code",[_._v("ACK")]),_._v("，确认号，指出下一个期望接收的"),e("code",[_._v("SEQ")]),_._v("(接受完毕)")]),_._v(" "),e("p",[_._v("举个例子：")]),_._v(" "),e("ol",[e("li",[_._v("序列号为"),e("code",[_._v("＃2000")]),_._v("且长度为"),e("code",[_._v("100")]),_._v("的数据包，在此连接上包含第"),e("code",[_._v("2000-2099")]),_._v("个字节。")]),_._v(" "),e("li",[_._v("当接收器接收到包括第"),e("code",[_._v("2099")]),_._v("字节在内的所有字节时，它发送一个确认"),e("code",[_._v("＃2100")]),_._v("。")]),_._v(" "),e("li",[_._v("表示它已在第"),e("code",[_._v("2100")]),_._v("字节之前接收到该字节。")])]),_._v(" "),e("p",[e("img",{attrs:{src:t(389),alt:"TCP三次握手2"}})]),_._v(" "),e("h2",{attrs:{id:"tcp-连接的-三次握手"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tcp-连接的-三次握手"}},[_._v("#")]),_._v(" TCP 连接的“三次握手”")]),_._v(" "),e("p",[e("img",{attrs:{src:t(390),alt:"TCP三次握手"}})]),_._v(" "),e("p",[_._v("第一次握手：客户端发送SYN包(syn=j)到服务器，并进入"),e("strong",[_._v("SYN_SEND")]),_._v("状态，等待服务器确认；")]),_._v(" "),e("p",[_._v("第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入"),e("strong",[_._v("SYN_RECV")]),_._v("状态；")]),_._v(" "),e("p",[_._v("第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入"),e("strong",[_._v("ESTABLISHED")]),_._v("状态，完成三次握手。")]),_._v(" "),e("p",[_._v("握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。")]),_._v(" "),e("p",[_._v("理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。")]),_._v(" "),e("p",[_._v("断开连接时服务器和客户端均可以主动发起断开TCP连接的请求，断开过程需要经过“四次挥手”")]),_._v(" "),e("h2",{attrs:{id:"tcp-断开的-四次挥手"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tcp-断开的-四次挥手"}},[_._v("#")]),_._v(" TCP 断开的“四次挥手”")]),_._v(" "),e("p",[e("img",{attrs:{src:t(391),alt:"TCP四次挥手"}})]),_._v(" "),e("p",[_._v("因为服务端在接收到"),e("code",[_._v("FIN")]),_._v(", 往往不会立即返回"),e("code",[_._v("FIN")]),_._v(", 必须等到服务端所有的报文都发送完毕了，才能发"),e("code",[_._v("FIN")]),_._v("。因此先发一个"),e("code",[_._v("ACK")]),_._v("表示已经收到客户端的"),e("code",[_._v("FIN")]),_._v("，延迟一段时间才发"),e("code",[_._v("FIN")]),_._v("。这就造成了四次挥手。")]),_._v(" "),e("h3",{attrs:{id:"如果是三次挥手会有什么问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如果是三次挥手会有什么问题"}},[_._v("#")]),_._v(" 如果是三次挥手会有什么问题？")]),_._v(" "),e("p",[_._v("等于说服务端将"),e("code",[_._v("ACK")]),_._v("和"),e("code",[_._v("FIN")]),_._v("的发送合并为一次挥手，这个时候长时间的延迟可能会导致客户端误以为"),e("code",[_._v("FIN")]),_._v("没有到达客户端，从而让客户端不断的重发"),e("code",[_._v("FIN")]),_._v("。")]),_._v(" "),e("h2",{attrs:{id:"为什么time-wait状态需要经过2msl-最大报文段生存时间-才能返回到close状态"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#为什么time-wait状态需要经过2msl-最大报文段生存时间-才能返回到close状态"}},[_._v("#")]),_._v(" 为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？")]),_._v(" "),e("p",[_._v("虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。")]),_._v(" "),e("h2",{attrs:{id:"为什么不能用两次握手进行连接"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#为什么不能用两次握手进行连接"}},[_._v("#")]),_._v(" 为什么不能用两次握手进行连接？")]),_._v(" "),e("blockquote",[e("p",[_._v("如果两次就ok，则服务器只要收到一个对应的是数据包，则默认建立连接，造成资源浪费。")])]),_._v(" "),e("p",[_._v("3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。")]),_._v(" "),e("p",[_._v("现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。")]),_._v(" "),e("h2",{attrs:{id:"如果已经建立了连接-但是客户端突然出现故障了怎么办"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如果已经建立了连接-但是客户端突然出现故障了怎么办"}},[_._v("#")]),_._v(" 如果已经建立了连接，但是客户端突然出现故障了怎么办？")]),_._v(" "),e("p",[_._v("TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。")]),_._v(" "),e("h2",{attrs:{id:"能不能说一说-tcp-和-udp-的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#能不能说一说-tcp-和-udp-的区别"}},[_._v("#")]),_._v(" 能不能说一说 TCP 和 UDP 的区别？")]),_._v(" "),e("p",[_._v("首先概括一下基本的区别:")]),_._v(" "),e("p",[e("strong",[_._v("TCP是一个面向连接的、可靠的、基于字节流的传输层协议。")])]),_._v(" "),e("p",[_._v("而"),e("strong",[_._v("UDP是一个面向无连接的传输层协议。")]),_._v("(就这么简单，其它TCP的特性也就没有了)。")]),_._v(" "),e("p",[_._v("具体来分析，和 "),e("code",[_._v("UDP")]),_._v(" 相比，"),e("code",[_._v("TCP")]),_._v(" 有三大核心特性:")]),_._v(" "),e("ol",[e("li",[e("strong",[_._v("面向连接")]),_._v("。所谓的连接，指的是客户端和服务器的连接，在双方互相通信之前，TCP 需要三次握手建立连接，而 UDP 没有相应建立连接的过程。")]),_._v(" "),e("li",[e("strong",[_._v("可靠性")]),_._v("。TCP 花了非常多的功夫保证连接的可靠，这个可靠性体现在哪些方面呢？一个是有状态，另一个是可控制。")])]),_._v(" "),e("p",[_._v("TCP 会精准记录哪些数据发送了，哪些数据被对方接收了，哪些没有被接收到，而且保证数据包按序到达，不允许半点差错。这是"),e("strong",[_._v("有状态")]),_._v("。")]),_._v(" "),e("p",[_._v("当意识到丢包了或者网络环境不佳，TCP 会根据具体情况调整自己的行为，控制自己的发送速度或者重发。这是"),e("strong",[_._v("可控制")]),_._v("。")]),_._v(" "),e("p",[_._v("相应的，UDP 就是"),e("code",[_._v("无状态")]),_._v(", "),e("code",[_._v("不可控")]),_._v("的。")]),_._v(" "),e("ol",[e("li",[e("strong",[_._v("面向字节流")]),_._v("。UDP 的数据传输是基于数据报的，这是因为仅仅只是继承了 IP 层的特性，而 TCP 为了维护状态，将一个个 IP 包变成了字节流。")])]),_._v(" "),e("h2",{attrs:{id:"三次握手过程中可以携带数据么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三次握手过程中可以携带数据么"}},[_._v("#")]),_._v(" 三次握手过程中可以携带数据么？")]),_._v(" "),e("p",[_._v("第三次握手的时候，可以携带。前两次握手不能携带数据。")]),_._v(" "),e("p",[_._v("如果前两次握手能够携带数据，那么一旦有人想攻击服务器，那么他只需要在第一次握手中的 SYN 报文中放大量数据，那么服务器势必会消耗更多的"),e("strong",[_._v("时间")]),_._v("和"),e("strong",[_._v("内存空间")]),_._v("去处理这些数据，增大了服务器被攻击的风险。")]),_._v(" "),e("p",[_._v("第三次握手的时候，客户端已经处于"),e("code",[_._v("ESTABLISHED")]),_._v("状态，并且已经能够确认服务器的接收、发送能力正常，这个时候相对安全了，可以携带数据。")]),_._v(" "),e("h2",{attrs:{id:"同时建立tcp连接"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#同时建立tcp连接"}},[_._v("#")]),_._v(" 同时建立TCP连接")]),_._v(" "),e("p",[e("img",{attrs:{src:t(392),alt:"同时建立TCP连接"}})]),_._v(" "),e("blockquote",[e("p",[_._v("不会阻塞，正常连接")])]),_._v(" "),e("p",[_._v("在发送方给接收方发"),e("code",[_._v("SYN")]),_._v("报文的同时，接收方也给发送方发"),e("code",[_._v("SYN")]),_._v("报文，两个人刚上了!")]),_._v(" "),e("p",[_._v("发完"),e("code",[_._v("SYN")]),_._v("，两者的状态都变为"),e("code",[_._v("SYN-SENT")]),_._v("。")]),_._v(" "),e("p",[_._v("在各自收到对方的"),e("code",[_._v("SYN")]),_._v("后，两者状态都变为"),e("code",[_._v("SYN-REVD")]),_._v("。")]),_._v(" "),e("p",[_._v("接着会回复对应的"),e("code",[_._v("ACK + SYN")]),_._v("，这个报文在对方接收之后，两者状态一起变为"),e("code",[_._v("ESTABLISHED")]),_._v("。")]),_._v(" "),e("p",[_._v("这就是同时打开情况下的状态变迁。")]),_._v(" "),e("h2",{attrs:{id:"说说半连接队列和-syn-flood-攻击的关系"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#说说半连接队列和-syn-flood-攻击的关系"}},[_._v("#")]),_._v(" 说说半连接队列和 SYN Flood 攻击的关系")]),_._v(" "),e("p",[_._v("三次握手前，服务端的状态从"),e("code",[_._v("CLOSED")]),_._v("变为"),e("code",[_._v("LISTEN")]),_._v(", 同时在内部创建了两个队列："),e("strong",[_._v("半连接队列")]),_._v("和"),e("strong",[_._v("全连接队列")]),_._v("，即"),e("strong",[_._v("SYN队列")]),_._v("和"),e("strong",[_._v("ACCEPT队列")]),_._v("。")]),_._v(" "),e("h3",{attrs:{id:"半连接队列"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#半连接队列"}},[_._v("#")]),_._v(" 半连接队列")]),_._v(" "),e("p",[_._v("当客户端发送"),e("code",[_._v("SYN")]),_._v("到服务端，服务端收到以后回复"),e("code",[_._v("ACK")]),_._v("和"),e("code",[_._v("SYN")]),_._v("，状态由"),e("code",[_._v("LISTEN")]),_._v("变为"),e("code",[_._v("SYN_RCVD")]),_._v("，此时这个连接就被推入了"),e("strong",[_._v("SYN队列")]),_._v("，也就是"),e("strong",[_._v("半连接队列")]),_._v("。")]),_._v(" "),e("h3",{attrs:{id:"全连接队列"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#全连接队列"}},[_._v("#")]),_._v(" 全连接队列")]),_._v(" "),e("p",[_._v("当客户端返回"),e("code",[_._v("ACK")]),_._v(", 服务端接收后，三次握手完成。这个时候连接等待被具体的应用取走，在被取走之前，它会被推入另外一个 TCP 维护的队列，也就是"),e("strong",[_._v("全连接队列(Accept Queue)")]),_._v("。")]),_._v(" "),e("h3",{attrs:{id:"syn-flood-攻击原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#syn-flood-攻击原理"}},[_._v("#")]),_._v(" SYN Flood 攻击原理")]),_._v(" "),e("p",[_._v("SYN Flood 属于典型的 DoS/DDoS 攻击。其攻击的原理很简单，就是用客户端在短时间内伪造大量不存在的 IP 地址，并向服务端疯狂发送"),e("code",[_._v("SYN")]),_._v("。对于服务端而言，会产生两个危险的后果:")]),_._v(" "),e("ol",[e("li",[e("p",[_._v("处理大量的"),e("code",[_._v("SYN")]),_._v("包并返回对应"),e("code",[_._v("ACK")]),_._v(", 势必有大量连接处于"),e("code",[_._v("SYN_RCVD")]),_._v("状态，从而占满整个"),e("strong",[_._v("半连接队列")]),_._v("，无法处理正常的请求。")])]),_._v(" "),e("li",[e("p",[_._v("由于是不存在的 IP，服务端长时间收不到客户端的"),e("code",[_._v("ACK")]),_._v("，会导致服务端不断重发数据，直到耗尽服务端的资源。")])])]),_._v(" "),e("h3",{attrs:{id:"如何应对-syn-flood-攻击"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如何应对-syn-flood-攻击"}},[_._v("#")]),_._v(" 如何应对 SYN Flood 攻击？")]),_._v(" "),e("ol",[e("li",[_._v("增加 SYN 连接，也就是增加半连接队列的容量。")]),_._v(" "),e("li",[_._v("减少 SYN + ACK 重试次数，避免大量的超时重发。")]),_._v(" "),e("li",[_._v("利用 SYN Cookie 技术，在服务端接收到"),e("code",[_._v("SYN")]),_._v("后不立即分配连接资源，而是根据这个"),e("code",[_._v("SYN")]),_._v("计算出一个Cookie，连同第二次握手回复给客户端，在客户端回复"),e("code",[_._v("ACK")]),_._v("的时候带上这个"),e("code",[_._v("Cookie")]),_._v("值，服务端验证 Cookie 合法之后才分配连接资源。")])])])}),[],!1,null,null,null);v.default=s.exports}}]);