(window.webpackJsonp=window.webpackJsonp||[]).push([[140],{540:function(e,v,t){"use strict";t.r(v);var _=t(46),a=Object(_.a)({},(function(){var e=this,v=e.$createElement,t=e._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"框架相关"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#框架相关"}},[e._v("#")]),e._v(" 框架相关")]),e._v(" "),t("h2",{attrs:{id:"写-react-vue-项目时为什么要在列表组件中写-key"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#写-react-vue-项目时为什么要在列表组件中写-key"}},[e._v("#")]),e._v(" 写 React / Vue 项目时为什么要在列表组件中写 key？")]),e._v(" "),t("blockquote",[t("p",[t("code",[e._v("key")]),e._v(" 是给每一个 "),t("code",[e._v("vnode")]),e._v(" 的唯一 "),t("code",[e._v("id")]),e._v(" ,可以 "),t("strong",[e._v("依靠key")]),e._v(", 更 "),t("strong",[e._v("准确")]),e._v(" , 更 "),t("strong",[e._v("快")]),e._v(" 的拿到 "),t("code",[e._v("oldVnode")]),e._v(" 中对应的 "),t("code",[e._v("vnode")]),e._v(" 节点。")])]),e._v(" "),t("p",[e._v("在被循环节点/组件非常简单的情况下，不传 "),t("code",[e._v("key")]),e._v(" 或传入 "),t("code",[e._v("index")]),e._v(" 都会导致diff时作为 "),t("code",[e._v("sameVnode")]),e._v("，粗暴的进行节点复用，会增加额外的diff开销，也会丢失过渡效果。")]),e._v(" "),t("p",[e._v("但是在 "),t("strong",[e._v("列表稳定")]),e._v(" 的情况下，不使用 "),t("code",[e._v("key")]),e._v(" 确实会更快一点。但是对于 "),t("strong",[e._v("频繁更新")]),e._v(" 使用 "),t("code",[e._v("key")]),e._v(" ,减少diff开销，性能会更好一点。")]),e._v(" "),t("p",[e._v("结论："),t("code",[e._v("key")]),e._v(" 的作用是为了在diff算法执行时更快的找到对应的节点，提高diff速度。")]),e._v(" "),t("h2",{attrs:{id:"virtual-dom-真的比操作原生-dom-快吗"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#virtual-dom-真的比操作原生-dom-快吗"}},[e._v("#")]),e._v(" Virtual DOM 真的比操作原生 DOM 快吗？")]),e._v(" "),t("p",[e._v("这是一个性能 vs 可维护性的取舍。")]),e._v(" "),t("p",[e._v("但是优秀的 Virtual DOM 和 diff，在绝大多数会比操作原生 DOM 快。")]),e._v(" "),t("blockquote",[t("p",[t("strong",[e._v("对 React 的 Virtual DOM 的误解")])]),e._v(" "),t("p",[e._v("React 从来没有说过 “React 比原生操作 DOM 快”。React 的基本思维模式是每次有变动就整个重新渲染整个应用。如果没有 Virtual DOM，简单来想就是直接重置 innerHTML。很多人都没有意识到，在一个大型列表所有数据都变了的情况下，重置 innerHTML 其实是一个还算合理的操作... 真正的问题是在 “全部重新渲染” 的思维模式下，即使只有一行数据变了，它也需要重置整个 innerHTML，这时候显然就有大量的浪费。")])]),e._v(" "),t("p",[e._v("不要天真地以为 Virtual DOM 就是快，diff 不是免费的，batching 么 MVVM 也能做，而且最终 patch 的时候还不是要用原生 API。在我看来 Virtual DOM 真正的价值从来都不是性能，而是它")]),e._v(" "),t("ol",[t("li",[t("p",[e._v("为函数式的 UI 编程方式打开了大门；")])]),e._v(" "),t("li",[t("p",[e._v("可以渲染到 DOM 以外的 backend，比如 ReactNative。")])])]),e._v(" "),t("h2",{attrs:{id:"为什么-vuex-的-mutation-和-redux-的-reducer-中不能做异步操作"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么-vuex-的-mutation-和-redux-的-reducer-中不能做异步操作"}},[e._v("#")]),e._v(" 为什么 Vuex 的 mutation 和 Redux 的 reducer 中不能做异步操作")]),e._v(" "),t("p",[e._v("如果经常用React+Redux开发，那么就应该了解Redux的设计初衷。Redux的设计参考了Flux的模式，作者希望以此来实现时间旅行，保存应用的历史状态，实现应用状态的可预测。所以整个Redux都是函数式编程的范式，要求reducer是 "),t("strong",[e._v("纯函数")]),e._v(" 也是自然而然的事情，"),t("strong",[e._v("使用纯函数才能保证相同的输入得到相同的输入，保证状态的可预测")]),e._v(" 。所以Redux有三大原则：")]),e._v(" "),t("ul",[t("li",[e._v("单一数据源，也就是state")]),e._v(" "),t("li",[e._v("state 是只读，Redux并没有暴露出直接修改state的接口，必须通过action来触发修改")]),e._v(" "),t("li",[e._v("使用纯函数来修改state，reducer必须是纯函数")])]),e._v(" "),t("h2",{attrs:{id:"vuex、flux、redux、redux-saga、dva、mobx-原理及对比"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vuex、flux、redux、redux-saga、dva、mobx-原理及对比"}},[e._v("#")]),e._v(" Vuex、Flux、Redux、Redux-saga、Dva、MobX 原理及对比")]),e._v(" "),t("blockquote",[t("p",[t("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/53599723",target:"_blank",rel:"noopener noreferrer"}},[e._v("知乎：Vuex、Flux、Redux、Redux-saga、Dva、MobX"),t("OutboundLink")],1)])]),e._v(" "),t("h2",{attrs:{id:"vue-和-react-diff-的异同"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue-和-react-diff-的异同"}},[e._v("#")]),e._v(" Vue 和 React diff 的异同")]),e._v(" "),t("p",[e._v("vue 和 react 的 diff 算法，都是忽略跨级比较，只做同级比较。")]),e._v(" "),t("ol",[t("li",[t("p",[e._v("vue 比对节点，当节点元素类型相同，但是 "),t("code",[e._v("className")]),e._v("不同，任务是不同类型元素，删除重建，而 react 会认为是同类型节点，只是修改节点属性")])]),e._v(" "),t("li",[t("p",[e._v("vue 的列表比对，采用从两端到中间的比对方式，而 react 则采用从左到右依次比对的方式。当一个集合，只是把最后一个节点移动到了第一个，react 会把前面的节点依次移动，而 vue 只会把最后一个节点移动到第一个。总体上，vue 的对比方式更高效。")])])]),e._v(" "),t("h2",{attrs:{id:"vue-和-react-的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue-和-react-的区别"}},[e._v("#")]),e._v(" Vue 和 React 的区别")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("监听数据变化的实现原理不同")]),e._v(" "),t("p",[e._v("Vue 通过数据监听，劫持，实现视图更新。React 通过手动触发 "),t("code",[e._v("setState")]),e._v(" 进而触发 "),t("code",[e._v("render")]),e._v(" 实现视图更新。")])]),e._v(" "),t("li",[t("p",[e._v("数据流的不同")]),e._v(" "),t("p",[e._v("Vue 双向绑定。React 单向数据流")])]),e._v(" "),t("li",[t("p",[e._v("HoC/Hooks 和 mixins")]),e._v(" "),t("p",[e._v("抽离组件逻辑。")])]),e._v(" "),t("li",[t("p",[e._v("组件通信的区别")]),e._v(" "),t("p",[e._v("Vue provied/inject。React Context")])]),e._v(" "),t("li",[t("p",[e._v("模板渲染方式的不同")]),e._v(" "),t("p",[e._v("Vue 模板。React jsx")])]),e._v(" "),t("li",[t("p",[e._v("渲染过程不同")]),e._v(" "),t("p",[e._v("Vue 通过数据监听，劫持自动更新、渲染局部内容。\nReact 通过 "),t("code",[e._v("setState")]),e._v(" 触发整个组件 "),t("code",[e._v("render")]),e._v(" 再进行 diff，最后更新局部内容。")])]),e._v(" "),t("li",[t("p",[e._v("框架本质不同")]),e._v(" "),t("p",[e._v("Vue MVVM。React 组件化。")])]),e._v(" "),t("li",[t("p",[e._v("Vuex 和 Redux 的区别")]),e._v(" "),t("p",[e._v("Vuex 绑定在 "),t("code",[e._v("store")]),e._v("，数据可变。\nRedux 数据不可变。")])])])])}),[],!1,null,null,null);v.default=a.exports}}]);