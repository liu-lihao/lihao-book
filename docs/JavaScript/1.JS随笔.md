# JS随笔

## JS数据类型，值是如何存储的

1. 基本类型：`Undefined`、`Null`、`Boolean`、`Number`、`String`、`Symbol`（ES6，独一无二）、`BigInt`（ES10，大数）。

    存储在 **栈(stack)** 。占据空间小，大小固定。

2. 引用类型：`Object`

    指针存储在 **栈(stack)** ，数据存储在 **堆(heap)** 。占据空间大，大小不固定。

## && 、 ||和!! 运算符

* `&&` ： 逻辑与，返回找到的第一个虚值，如果没有则返回最后一个真值。

* `||` ： 逻辑或，返回找到的第一个真值，如果没有则返回最后一个虚值。

* `!!` ： 转 `Boolean` 类型。

## JS类型判断

* `typeof`
  * 可能返回：`object`/`number`/`string`/`boolean`/`function`/`undefined`/`symbol`/`bigint`
  * `typeof null` 返回 `object`

* `instanceof`
  * 通过判断对象的原型链中是不是能找到类型的 `prototype`。
  * 无法判断基本类型

* `constructor`
  * 可改，有时不太靠谱。
  
* `Object.prototype.toString.call()`
  * 比较靠谱
  * `Object.prototype.toString.call(null); // "[object Null]"`

## 作用域和作用域链

* **作用域** ： 作用域是定义变量的区域，它有一套访问变量的规则，这套规则来管理浏览器引擎如何在当前作用域以及嵌套的作用域中根据变量（标识符）进行变量查找。

* **作用域链** ： 作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，我们可以访问到外层环境的变量和函数。

## 原型和原型链

* 浏览器实现的`__proto__`，不是标准的规范，建议使用 `Object.getPrototypeOf()`，也可以使用 `p.constructor.prototype`的方式。

* 当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又 会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 `Object.prototype` 所以这就 是我们新建的对象为什么能够使用 `toString()` 等方法的原因。

## JavaScript 创建对象的几种方式？

1. **工厂模式** ：工厂模式的主要工作原理是用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。但是它有一个很大的问题就是创建出来的对象无法和某个类型联系起来，它只是简单的封装了复用代码，而没有建立起对象和类型间的关系。 

2. **构造函数模式** ：js 中每一个函数都可以作为构造函数，只要一个函数是通过 new 来调用的。执行构造函数首先会创建一个对象，然后将对象的原型指向构造函数的 prototype 属性，然后将执行上下文中的 this 指向这个对象，最后再执行整个函数，如果返回值不是对象，则返回新建的对象。因为 this 的值指向了新建的对象，因此我们可以使用 this 给对象赋值。构造函数模式相对于工厂模式的优点是，所创建的对象和构造函数建立起了联系，因此我们可以通过原型来识别对象的类型。但是构造函数存在一个缺点就是，造成了不必要的函数对象的创建，因为在 js 中函数也是一个对象，因此如果对象属性中如果包含函数的话，那么每次我们都会新建一个函数对象，浪费了不必要的内存空间，因为函数是所有的实例都可以通用的。 

3. **原型模式** ：因为每一个函数都有一个 prototype 属性，这个属性是一个对象，它包含了通过构造函数创建的所有实例都能共享的属性和方法。因此我们可以使用原型对象来添加公用属性和方法，从而实现代码的复用。这种方式相对于构造函数模式来说，解决了函数对象的复用问题。但是这种模式也存在一些问题，一个是没有办法通过传入参数来初始化值，另一个是如果存在一个引用类型如 Array 这样的值，那么所有的实例将共享一个对象，一个实例对引用类型值的改变会影响所有的实例。 

4. **组合使用构造函数模式和原型模式** ：这是创建自定义类型的最常见方式。因为构造函数模式和原型模式分开使用都存在一些问题，因此我们可以组合使用这两种模式，通过构造函数来初始化对象的属性，通过原型对象来实现函数方法的复用。这种方法很好的解决了两种模式单独使用时的缺点，但是有一点不足的就是，因为使用了两种不同的模式，所以对于代码的封装性不够好。 

5. **动态原型模式** ：这一种模式将原型方法赋值的创建过程移动到了构造函数的内部，通过对属性是否存在的判断，可以实现仅在第一次调用函数时对原型对象赋值一次的效果。这一种方式很好地对上面的混合模式进行了封装。 

6. **寄生构造函数模式** ：这一种模式和工厂模式的实现基本相同，我对这个模式的理解是，它主要是基于一个已有的类型，在实例化时对实例化的对象进行扩展。这样既不用修改原来的构造函数，也达到了扩展对象的目的。它的一个缺点和工厂模式一样，无法实现对象的识别。

## JavaScript 继承的几种实现方式？

1. **以原型链的方式来实现继承** ：但是这种实现方式存在的缺点是，在包含有引用类型的数据时，会被所有的实例对象所共享，容易造成修改的混乱。还有就是在创建子类型的时候不能向超类型传递参数。

2. **使用借用构造函数的方式** ：这种方式是通过在子类型的函数中调用超类型的构造函数来实现的，这一种方法解决了不能向超类型传递参数的缺点，但是它存在的一个问题就是无法实现函数方法的复用，并且超类型原型定义的方法子类型也没有办法访问到。

3. **组合继承** ：组合继承是将原型链和借用构造函数组合起来使用的一种方式。通过借用构造函数的方式来实现类型的属性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。这种方式解决了上面的两种模式单独使用时的问题，但是由于我们是以超类型的实例来作为子类型的原型，所以调用了两次超类的构造函数，造成了子类型的原型中多了很多不必要的属性。

4. **原型式继承** ：原型式继承的主要思路就是基于已有的对象来创建新的对象，实现的原理是，向函数中传入一个对象，然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为了实现创造一种新的类型，只是对某个对象实现一种简单继承，ES5 中定义的 `Object.create() `方法就是原型式继承的实现。缺点与原型链方式相同。

5. **寄生式继承** ：寄生式继承的思路是创建一个用于封装继承过程的函数，通过传入一个对象，然后复制一个对象的副本，然后对象进行扩展，最后返回这个对象。这个扩展的过程就可以理解是一种继承。这种继承的优点就是对一个简单对象实现继承，如果这个对象不是我们的自定义类型时。缺点是没有办法实现函数的复用。

6. **寄生式组合继承** ：组合继承的缺点就是使用超类型的实例做为子类型的原型，导致添加了不必要的原型属性。寄生式组合继承的方式是使用超类型的原型的副本来作为子类型的原型，这样就避免了创建不必要的属性。

## 闭包

闭包是指有权访问另一个函数作用域内变量的函数，其实闭包的本质就是作用域链的一个特殊的应用。

## 事件委托

本质上是利用了浏览器事件冒泡的机制。

## 延迟加载js

* js置底
* 给 `<script>`  添加 `defer` 属性
* 给 `<script>` 添加 `async` 属性
* 动态创建 `<script>`

## `var` , `let` 和 `const` 的区别是什么？

1. `var` 声明的变量会挂载在 `window` 上，而 `let` 和 `const` 声明的变量不会：

2. `var` 声明变量存在变量提升， `let` 和 `const` 不存在变量提升:

3. `let` 和 `const` 声明形成块作用域

4. 同一作用域下 `let` 和 `const` 不能声明同名变量，而var可以

5. 暂存死区
    ```js
    var a = 100;

    if (1) {
      a = 10;
      //在当前块作用域中存在a使用let/const声明的情况下，给a赋值10时，只会在当前作用域找变量a，
      // 而这时，还未到声明时候，所以控制台Error:a is not defined
      let a = 1;
    }
    ```
    
6. `const`

    * 声明必须赋值
    * 引用类型指针不可改变
    * 基本类型不可变

## 声明变量的方式

ES5 只有两种声明变量的方法：`var` 命令和 `function` 命令。ES6 除了添加 `let` 和 `const` 命令，后面章节还会提到，另外两种声明变量的方法： `import` 命令和 `class` 命令。所以，ES6 一共有 6 种声明变量的方法。

所以：`var`、`function`、`let`、`const`、`import`、`class`

## async/await 优缺点

`async/await`的优势在于处理 `then` 的调用链，能够更清晰准确的写出代码，并且也能优雅地解决回调地狱问题。当然也存在一些缺点，因为 `await` 将异步代码改造成了同步代码，如果多个异步代码没有依赖性却使用了 `await` 会导致性能上的降低。

需要注意，只要加上了 `async` 的函数，无论返回什么都会变成 `Promise`，（比如返回`3`，则转换为`Promise.resolve(3)` 。若返回自身就是 `Promise` 则直接返回自身）。

## 同一浏览器实现多个标签页通信

最优方式：使用`localStorage`，监听`storage`。

```javascript
  window.addEventListener('storage', e => {
    console.log(e);
  }, false);
```
- 触发条件:
   1. `localStorage`发生变化(`sessionStorage`无效)。
   2. `localStorage.clear()`，若本身为空，则不会触发。
   3. 同一个html不会触发，需在服务器上不同的html，即域名、端口、协议相同的不同页面。



## hash路由的实现

原理：url中`#`号及其后面的内容不会作为有效网址，并且当#号及其后面内容发生改变是会触发`hashchange`事件。

```javascript
window.addEventListener('hashchange', e => {
  //这里加上判断，并可以通过动态加载js实现按需加载js。
}, false);
```

按需加载js:

```javascript
document.body.appendChild(document.createElement("script")).src="test-router.js";
```


## Array.sort()

一直以为它的作用仅仅是纯数字数组排序，直到最近才发现我错了，原来它对不太多的各种数据排序都很方便。

- 默认情况：

  1. 默认排序规则：字符串方式

  2. 默认排序顺序：递增

  3. Demo：
    ```javascript
    [2,6,4,10].sort(); //  [10, 2, 4, 6]
    ```

- 传入比较函数：

  1. 比较函数：

    ```javascript
    function compare (value1,value2){//递增排序
      if(value1 < value2) return -1;
      if(value1 > value2) return 1;
      return 0;
      //如果希望小的数字在左边(arr[0]最小),则对value1来说，小的话要放到左边去，返回<0的数。
      //如果希望大的数字在左边(arr[0]最大),则对value1来说，小的话要放到右边去，返回>0的数。
      //相等的话返回0。
      //总的来说：两个参数比较，随便返回-1/1，0不用管，不是想要的顺序就换了一下-1/1就行了。
    }
    ```

  2. Demo：

    ```javascript
    let arr2 = [{"num":2},{"num":6},{"num":4},{"num":10}];
    arr2.sort((v1,v2) =>v1.num - v2.num);
    console.log(arr2);//[{"num":2},{"num":4},{"num":6},{"num":10}]
    ```
