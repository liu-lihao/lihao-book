**rollup.js**

# 插件开发

## 插件概述

Rollup 插件是具有以下一个或多个[属性](https://rollupjs.org/guide/en/#properties)，[构建挂钩](https://rollupjs.org/guide/en/#build-hooks)和[输出生成挂钩的对象](https://rollupjs.org/guide/en/#output-generation-hooks)，并且遵循我们的[约定](https://rollupjs.org/guide/en/#conventions)。插件应作为软件包分发，该软件包导出可以使用插件特定选项调用的函数并返回此类对象。

插件使您可以通过以下方式来自定义 Rollup 的行为，例如，在捆绑之前转码代码，或在`node_modules`文件夹中找到第三方模块。有关如何使用它们的示例，请参见[使用插件](https://rollupjs.org/guide/en/#using-plugins)。

插件列表可以在[github.com/rollup/awesome](https://github.com/rollup/awesome)上找到。如果您想对插件提出建议，请提交请求请求。

## 一个简单的例子

以下插件将拦截任何导入，`virtual-module`而无需访问文件系统。例如，如果要在浏览器中使用汇总，则这是必需的。如示例中所示，它甚至可以用来替换入口点。

```js
// rollup-plugin-my-example.js
export default function myExample() {
  return {
    name: 'my-example', // this name will show up in warnings and errors
    resolveId(source) {
      if (source === 'virtual-module') {
        return source // this signals that rollup should not ask other plugins or check the file system to find this id
      }
      return null // other ids should be handled as usually
    },
    load(id) {
      if (id === 'virtual-module') {
        return 'export default "This is virtual!"' // the source code for "virtual-module"
      }
      return null // other ids should be handled as usually
    },
  }
}

// rollup.config.js
import myExample from './rollup-plugin-my-example.js'
export default {
  input: 'virtual-module', // resolved by our plugin
  plugins: [myExample()],
  output: [
    {
      file: 'bundle.js',
      format: 'es',
    },
  ],
}
```

## 约定

- 插件应使用带`rollup-plugin-`前缀的明确名称。
- 在中包含`rollup-plugin`关键字`package.json`。
- 插件应经过测试。我们建议开箱即用的[摩卡](https://github.com/mochajs/mocha)或[ava](https://github.com/avajs/ava)支持承诺。
- 尽可能使用异步方法。
- 用英语记录您的插件。
- 如果合适，请确保插件输出正确的源映射。
- 如果您的插件使用“虚拟模块”（例如用于辅助功能），请在模块 ID 前面加上`\0`。这样可以防止其他插件尝试对其进行处理。

## 特性

### `name`

类型： `string`

插件的名称，用于错误消息和警告。

## 搭钩

为了与构建过程进行交互，您的插件对象应包含“挂钩”。挂钩是在构建的各个阶段调用的函数。挂钩会影响构建的运行方式，提供有关构建的信息或在构建完成后修改构建。有不同种类的钩子：

- `async`：钩子也可能返回一个承诺，将其解析为相同类型的值；否则，该钩子将标记为`sync`。
- `first`：如果有多个插件实现了此挂钩，则挂钩会顺序运行，直到挂钩返回的值不是`null`或`undefined`。
- `sequential`：如果有多个插件实现了此挂钩，则所有插件将按照指定的插件顺序运行。如果一个钩子是异步的，则随后的这种钩子将等待，直到当前钩子被解析为止。
- `parallel`：如果有多个插件实现了此挂钩，则所有插件将按照指定的插件顺序运行。如果一个钩子是异步的，则随后的这种钩子将并行运行，而不等待当前的钩子。

构建挂钩在构建阶段运行，由触发`rollup.rollup(inputOptions)`。他们主要关注在汇总之前处理输入文件的查找，提供和转换。构建阶段的第一个钩子为[`options`](https://rollupjs.org/guide/en/#options)，最后一个钩子始终为[`buildEnd`](https://rollupjs.org/guide/en/#buildend)，除非存在构建错误，否则[`closeBundle`](https://rollupjs.org/guide/en/#closebundle)将在此之后调用。

此外，在监视模式下，[`watchChange`](https://rollupjs.org/guide/en/#watchchange)可以随时触发该挂钩，以通知新的运行将在当前运行生成其输出后触发。同样，当观察者关闭时，[`closeWatcher`](https://rollupjs.org/guide/en/#closewatcher)挂钩也会被触发。

请参阅[输出生成挂钩](https://rollupjs.org/guide/en/#output-generation-hooks)，以获取在输出生成阶段运行以修改生成的输出的挂钩。

### `buildEnd`

类型：`(error?: Error) => void`
种类：`async, parallel`
之前的符：[`moduleParsed`](https://rollupjs.org/guide/en/#moduleparsed)，[`resolveId`](https://rollupjs.org/guide/en/#resolveid)或[`resolveDynamicImport`](https://rollupjs.org/guide/en/#resolvedynamicimport)。
下一个挂钩：[`outputOptions`](https://rollupjs.org/guide/en/#outputoptions)在输出生成阶段，因为这是构建阶段的最后一个挂钩。

当汇总完成捆绑时调用，但在`generate`或之前`write`调用；您还可以返回一个 Promise。如果在构建过程中发生错误，则将其传递到该挂钩。

### `buildStart`

类型：`(options: InputOptions) => void`
种类：`async, parallel`
上一个挂钩： 下一个挂钩：并行解析每个入口点。[`options`](https://rollupjs.org/guide/en/#options)
[`resolveId`](https://rollupjs.org/guide/en/#resolveid)

在每个`rollup.rollup`版本上调用。当您需要访问传递到的选项时，建议使用此挂钩，`rollup.rollup()`因为它考虑了所有[`options`](https://rollupjs.org/guide/en/#options)挂钩的转换，并且还包含未设置选项的正确默认值。

### `closeWatcher`

类型：`() => void`
种类：`sync, sequential`
上一个/下一个挂钩：可以在构建阶段和输出生成阶段的任何时间触发此挂钩。如果是这种情况，当前构建仍将继续进行，但是[`watchChange`](https://rollupjs.org/guide/en/#watchchange)永远不会触发任何新事件。

当观察者进程关闭并且所有打开的资源也应该关闭时通知插件。输出插件不能使用此钩子。

### `load`

类型：`(id: string) => string | null | {code: string, map?: string | SourceMap, ast? : ESTree.Program, moduleSideEffects?: boolean | "no-treeshake" | null, syntheticNamedExports?: boolean | string | null, meta?: {[plugin: string]: any} | null}`
种类：`async, first`
上一个挂钩：[`resolveId`](https://rollupjs.org/guide/en/#resolveid)或[`resolveDynamicImport`](https://rollupjs.org/guide/en/#resolvedynamicimport)解析加载的 ID 的位置。
下一步：[`transform`](https://rollupjs.org/guide/en/#transform)转换已加载的文件。

定义一个自定义加载程序。`null`将延迟返回到其他`load`功能（并最终返回从文件系统加载的默认行为）。为了防止在`this.parse`由于某种原因该钩子已经用于生成 AST 的情况下产生额外的解析开销，该钩子可以选择返回一个`{ code, ast, map }`对象。在`ast`必须与标准 ESTree AST`start`和`end`属性为每个节点。如果转换不移动代码，则可以通过将设置`map`为来保留现有的源地图`null`。否则，您可能需要生成源映射。请参阅[有关源代码转换的部分](https://rollupjs.org/#source-code-transformations)。

如果`false`返回`moduleSideEffects`并且没有其他模块从该模块导入任何内容，那么即使该模块有副作用，该模块也不会包含在捆绑软件中。如果`true`返回，则汇总将使用其默认算法将模块中具有副作用（例如修改全局变量或导出变量）的所有语句包括在内。如果`"no-treeshake"`返回，则该模块的树状握手将被关闭，即使它为空，它也将包含在所生成的块中。如果`null`返回或省略该标志，则将`moduleSideEffects`由`resolveId`解析此模块的第一个钩子，该`treeshake.moduleSideEffects`选项确定，或者最终将其默认为`true`。该`transform`钩子可以覆盖。

有关该选项的作用，请参见[合成的命名导出](https://rollupjs.org/guide/en/#synthetic-named-exports)`syntheticNamedExports`。如果`null`返回或省略该标志，则将`syntheticNamedExports`由`resolveId`解析此模块的第一个挂钩确定，或最终默认为`false`。该`transform`钩子可以覆盖。

有关如何使用该选项[的信息](https://rollupjs.org/guide/en/#custom-module-meta-data)，请参见[自定义模块元数据](https://rollupjs.org/guide/en/#custom-module-meta-data)`meta`。如果`meta`此钩子返回一个对象，则它将与`meta`resolveId 钩子返回的任何对象进行浅层合并。如果没有钩子返回一个`meta`对象，它将默认为一个空对象。所述`transform`钩可以进一步添加或替换该对象的属性。

您可以使用[`this.getModuleInfo`](https://rollupjs.org/guide/en/#thisgetmoduleinfomoduleid-string--moduleinfo--null)来查找的先前值`moduleSideEffects`，`syntheticNamedExports`并`meta`在此挂钩内。

### `moduleParsed`

类型：`(moduleInfo: ModuleInfo) => void`
种类：`async, parallel`
上一个挂钩：[`transform`](https://rollupjs.org/guide/en/#transform)当前处理的文件被转换到的位置。
NextHook：[`resolveId`](https://rollupjs.org/guide/en/#resolveid)并[`resolveDynamicImport`](https://rollupjs.org/guide/en/#resolvedynamicimport)并行解析所有发现的静态和动态导入（如果存在），否则[`buildEnd`](https://rollupjs.org/guide/en/#buildend)。

每次 Rollup 完全解析模块时，都会调用此钩子。有关[`this.getModuleInfo`](https://rollupjs.org/guide/en/#thisgetmoduleinfomoduleid-string--moduleinfo--null)将什么信息传递到此挂钩的信息，请参见。

与该[`transform`](https://rollupjs.org/guide/en/#transform)钩子相比，此钩子从不缓存，可用于获取有关缓存的和其他模块的信息，包括`meta`属性的最终形状 the`code`和 the `ast`。

请注意，此钩子中尚未提供有关导入模块的信息，并且有关导入模块的信息可能不完整，因为以后可能会发现其他导入器。如果您需要此信息，请使用[`buildEnd`](https://rollupjs.org/guide/en/#buildend)挂钩。

### `options`

类型：`(options: InputOptions) => InputOptions | null`
种类：`async, sequential`
上一个挂钩：这是构建阶段的第一个挂钩。
下一个挂钩：[`buildStart`](https://rollupjs.org/guide/en/#buildstart)

替换或操纵传递给的 options 对象`rollup.rollup`。退货`null`不会替代任何东西。如果只需要阅读选项，则建议使用该[`buildStart`](https://rollupjs.org/guide/en/#buildstart)挂钩，因为`options`在考虑了所有挂钩的转换之后，该挂钩可以访问这些选项。

这是唯一无法访问大多数[插件上下文](https://rollupjs.org/guide/en/#plugin-context)实用程序功能的挂钩，因为它在完全配置汇总之前就已运行。

### `resolveDynamicImport`

类型：`(specifier: string | ESTree.Node, importer: string) => string | false | null | {id: string, external?: boolean}`
种类：`async, first`
Previous Hook：[`moduleParsed`](https://rollupjs.org/guide/en/#moduleparsed)用于导入文件。
下一个挂钩：[`load`](https://rollupjs.org/guide/en/#load)如果挂钩使用尚未加载的 ID 进行了解析，[`resolveId`](https://rollupjs.org/guide/en/#resolveid)则动态导入包含一个字符串并且未被挂钩解析，否则为[`buildEnd`](https://rollupjs.org/guide/en/#buildend)。

为动态导入定义自定义解析器。返回`false`信号表明导入应保持原样，并且不传递给其他解析器，从而将其置于外部。与[`resolveId`](https://rollupjs.org/guide/en/#resolveid)钩子类似，您还可以返回一个对象，以将导入解析为其他 id，同时将其标记为外部。

如果动态导入传递了一个字符串作为参数，则从该挂钩返回的字符串将被解释为现有的模块 ID，而返回时`null`将被推迟到其他解析器，最后是`resolveId`。

如果动态导入未传递字符串作为参数，则此钩子可以访问原始 AST 节点进行分析，并且在以下方面的行为略有不同：

- 如果所有插件都返回`null`，则将导入视为`external`没有警告。
- 如果返回一个字符串，则该字符串*不会被*解释为模块 ID，而是将其替换为 import 参数。插件负责确保生成的代码有效。
- 要解决对现有模块的这种导入问题，您仍然可以返回 object `{id, external}`。

请注意，此钩子的返回值不会在`resolveId`之后传递给它。如果需要访问静态解析算法，则可以[`this.resolve(source, importer)`](https://rollupjs.org/guide/en/#thisresolvesource-string-importer-string-options-skipself-boolean-custom-plugin-string-any--promiseid-string-external-boolean-modulesideeffects-boolean--no-treeshake-syntheticnamedexports-boolean--string-meta-plugin-string-any--null)在插件上下文中使用。

### `resolveId`

类型：`(source: string, importer: string | undefined, options: {custom?: {[plugin: string]: any}) => string | false | null | {id: string, external?: boolean, moduleSideEffects?: boolean | "no-treeshake" | null, syntheticNamedExports?: boolean | string | null, meta?: {[plugin: string]: any} | null}`
种类：`async, first`
上一个钩子：[`buildStart`](https://rollupjs.org/guide/en/#buildstart)如果我们要解决一个入口点，[`moduleParsed`](https://rollupjs.org/guide/en/#moduleparsed)如果我们要解决一个导入，或者作为后备[`resolveDynamicImport`](https://rollupjs.org/guide/en/#resolvedynamicimport)。另外，可以在构建阶段从插件挂钩通过调用[`this.emitFile`](https://rollupjs.org/guide/en/#thisemitfileemittedfile-emittedchunk--emittedasset--string)发出一个入口点来触发该挂钩，或者在任何时候通过调用[`this.resolve`](https://rollupjs.org/guide/en/#thisresolvesource-string-importer-string-options-skipself-boolean-custom-plugin-string-any--promiseid-string-external-boolean-modulesideeffects-boolean--no-treeshake-syntheticnamedexports-boolean--string-meta-plugin-string-any--null)手动解析一个 ID 来触发该挂钩。
下一个挂钩：[`load`](https://rollupjs.org/guide/en/#load)如果尚未加载已解析的 ID，则返回[`buildEnd`](https://rollupjs.org/guide/en/#buildend)。

定义一个自定义解析器。解析器对于例如定位第三方依赖项可能很有用。此处`source`的导入对象与导入语句中所写的完全相同，即

```js
import { foo } from '../bar.js'
```

来源将是`"../bar.js""`。

该`importer`是进口模块的完全解决 ID。解决入口点时，进口商为`undefined`。例如，您可以将其用作为入口点定义自定义代理模块的机制。

以下插件将仅公开来自入口点的默认导出，同时仍保留命名的导出供内部使用：

```js
async resolveId(source,importer) {
  if (!importer) {
    // We need to skip this plugin to avoid an infinite loop
    const resolution = await this.resolve(source, undefined, { skipSelf: true });
    // If it cannot be resolved, return `null` so that Rollup displays an error
    if (!resolution) return null;
    return `${resolution.id}?entry-proxy`;
  }
  return null;
},
load(id) {
  if (id.endsWith('?entry-proxy')) {
    const importee = id.slice(0, -'?entry-proxy'.length);
    // Note that this will throw if there is no default export
    return `export {default} from '${importee}';`;
  }
  return null;
}
```

`null`将延迟返回到其他`resolveId`函数，并最终返回默认的解析行为。返回`false`信号`source`应视为外部模块，不包含在捆绑包中。如果发生这种情况是相对导入，则将使用与`external`使用该选项时相同的方式对 ID 重新进行规范化。

如果返回对象，则可以将导入解析为其他 id，同时将其从捆绑中排除。这使您可以使用外部依赖关系替换依赖关系，而无需用户通过以下`external`选项将它们手动标记为“外部” ：

```js
resolveId(source) {
  if (source === 'my-dependency') {
    return {id: 'my-dependency-develop', external: true};
  }
  return null;
}
```

相对 ID，即开始`./`或`../`将**不会**返回一个对象时，可以重新归一化。如果您想要这种行为，请返回一个绝对的文件系统位置`id`。

如果在解析模块 ID 的第一个挂钩中`false`返回，`moduleSideEffects`并且没有其他模块从该模块导入任何内容，那么即使该模块有副作用，也不会包含该模块。如果`true`返回，则汇总将使用其默认算法将模块中具有副作用（例如修改全局变量或导出变量）的所有语句包括在内。如果`"no-treeshake"`返回，则该模块的树状握手将被关闭，即使它为空，它也将包含在所生成的块中。如果`null`返回或省略该标志，则将`moduleSideEffects`由该`treeshake.moduleSideEffects`选项确定或默认为`true`。该`load`和`transform`挂钩可以覆盖这一点。

有关该选项的作用，请参见[合成的命名导出](https://rollupjs.org/guide/en/#synthetic-named-exports)`syntheticNamedExports`。如果`null`返回或省略该标志，则`syntheticNamedExports`默认为`false`。该`load`和`transform`挂钩可以覆盖这一点。

有关如何使用该选项[的信息](https://rollupjs.org/guide/en/#custom-module-meta-data)，请参见[自定义模块元数据](https://rollupjs.org/guide/en/#custom-module-meta-data)`meta`。如果`null`返回或忽略该选项，则`meta`默认为空对象。的`load`和`transform`钩可以添加或替换该对象的属性。

当通过插件从插件触发此挂钩时[`this.resolve(source, importer, options)`](https://rollupjs.org/guide/en/#thisresolvesource-string-importer-string-options-skipself-boolean-custom-plugin-string-any--promiseid-string-external-boolean-modulesideeffects-boolean--no-treeshake-syntheticnamedexports-boolean--string-meta-plugin-string-any--null)，可以将自定义选项对象传递给此挂钩。尽管此对象将不加修改地传递，但插件应遵循为`custom`对象添加属性的约定，该对象的键与选项所要使用的插件的名称相对应。有关详细信息，请参见[自定义解析程序选项](https://rollupjs.org/guide/en/#custom-resolver-options)。

### `transform`

类型：`(code: string, id: string) => string | null | {code?: string, map?: string | SourceMap, ast? : ESTree.Program, moduleSideEffects?: boolean | "no-treeshake" | null, syntheticNamedExports?: boolean | string | null, meta?: {[plugin: string]: any} | null}`
种类：`async, sequential`
上一个挂钩：[`load`](https://rollupjs.org/guide/en/#load)当前处理的文件的加载位置。
NextHook：[`moduleParsed`](https://rollupjs.org/guide/en/#moduleparsed)文件被处理和解析后。

可用于转换单个模块。为了防止在`this.parse`由于某种原因该钩子已经用于生成 AST 的情况下产生额外的解析开销，该钩子可以选择返回一个`{ code, ast, map }`对象。在`ast`必须与标准 ESTree AST`start`和`end`属性为每个节点。如果转换不移动代码，则可以通过将设置`map`为来保留现有的源地图`null`。否则，您可能需要生成源映射。请参阅[有关源代码转换的部分](https://rollupjs.org/#source-code-transformations)。

请注意，在计时模式，这个钩子的结果重建时，高速缓存和钩只是再次触发模块`id`如果任一`code`模块的已更改或文件是否已更改这是通过添加`this.addWatchFile`最后一次钩被触发这个模块。

您还可以使用返回值的对象形式来配置模块的其他属性。请注意，有可能只返回属性，而没有代码转换。

如果`false`返回`moduleSideEffects`并且没有其他模块从该模块导入任何内容，那么即使该模块有副作用，也将不包括该模块。

如果`true`返回，则汇总将使用其默认算法将模块中具有副作用（例如修改全局变量或导出变量）的所有语句包括在内。

如果`"no-treeshake"`返回，则该模块的树状握手将被关闭，即使它为空，它也将包含在所生成的块中。

如果`null`返回或省略该标志，则将`moduleSideEffects`由`load`加载此模块的`resolveId`钩子，解析该模块的第一个钩子，该`treeshake.moduleSideEffects`选项或最终默认为来确定`true`。

有关该选项的作用，请参见[合成的命名导出](https://rollupjs.org/guide/en/#synthetic-named-exports)`syntheticNamedExports`。如果`null`返回或省略该标志，则将`syntheticNamedExports`由`load`加载此模块的`resolveId`钩子，解析该模块的第一个钩子，该`treeshake.moduleSideEffects`选项或最终默认为来确定`false`。

有关如何使用该选项[的信息](https://rollupjs.org/guide/en/#custom-module-meta-data)，请参见[自定义模块元数据](https://rollupjs.org/guide/en/#custom-module-meta-data)`meta`。如果`null`返回或忽略了该选项，则将`meta`由`load`加载该模块的`resolveId`钩子，解析该模块的第一个钩子或最终默认为空对象的钩子确定。

您可以使用[`this.getModuleInfo`](https://rollupjs.org/guide/en/#thisgetmoduleinfomoduleid-string--moduleinfo--null)来查找的先前值`moduleSideEffects`，`syntheticNamedExports`并`meta`在此挂钩内。

### `watchChange`

类型：`watchChange: (id: string, change: {event: 'create' | 'update' | 'delete'}) => void`
种类：`sync, sequential`
上一个/下一个挂钩：可以在构建阶段和输出生成阶段的任何时间触发此挂钩。如果是这种情况，当前构建仍将继续进行，但是计划在当前构建完成后开始新的构建，从再次开始[`options`](https://rollupjs.org/guide/en/#options)。

每当汇总检测到`--watch`模式下受监视文件的更改时，通知插件。输出插件不能使用此钩子。第二个参数包含更改事件的其他详细信息。

## 输出生成挂钩

输出生成挂钩可以提供有关生成的包的信息，并在完成后修改构建。它们的工作方式与[Build Hooks](https://rollupjs.org/guide/en/#build-hooks)相同，但与[Build Hooks](https://rollupjs.org/guide/en/#build-hooks)具有相同的类型，但每次调用`bundle.generate(outputOptions)`或时都分别调用它们`bundle.write(outputOptions)`。也可以通过输出选项传递仅使用输出生成挂钩的插件，因此仅对某些输出运行。

输出生成阶段的第一钩是[`outputOptions`](https://rollupjs.org/guide/en/#outputoptions)，最后一个是或者[`generateBundle`](https://rollupjs.org/guide/en/#generatebundle)如果经由成功产生的输出`bundle.generate(...)`，[`writeBundle`](https://rollupjs.org/guide/en/#writebundle)如果输出经成功生成`bundle.write(...)`，或者[`renderError`](https://rollupjs.org/guide/en/#rendererror)如果输出代期间的任何时候发生了错误。

此外，[`closeBundle`](https://rollupjs.org/guide/en/#closebundle)可以称为最后一个钩子，但是用户有责任手动调用[`bundle.close()`](https://rollupjs.org/guide/en/#rolluprollup)以触发此钩子。CLI 将始终确保是这种情况。

### `augmentChunkHash`

类型：`(chunkInfo: ChunkInfo) => string`
种类：`sync, sequential`
上一个挂钩：[`renderDynamicImport`](https://rollupjs.org/guide/en/#renderdynamicimport)每个动态导入表达式。
下一个挂钩：[`resolveFileUrl`](https://rollupjs.org/guide/en/#resolvefileurl)用于的每次使用`import.meta.ROLLUP_FILE_URL_referenceId`以及[`resolveImportMeta`](https://rollupjs.org/guide/en/#resolveimportmeta)对的所有其他访问`import.meta`。

可用于增加单个块的哈希值。为每个汇总输出块调用。返回一个伪造的值将不会修改哈希值。真实的价值将传递给[`hash.update`](https://nodejs.org/dist/latest-v12.x/docs/api/crypto.html#crypto_hash_update_data_inputencoding)。该`chunkInfo`是一个在的简化版本[`generateBundle`](https://rollupjs.org/guide/en/#generatebundle)，而不依赖于文件名的属性。

以下插件将`foo`使用上次构建的时间戳使块的哈希无效：

```js
// rollup.config.js
augmentChunkHash(chunkInfo) {
  if(chunkInfo.name === 'foo') {
    return Date.now().toString();
  }
}
```

### `banner`

类型：`string | (() => string)`
类型：`async, parallel`
上一个挂钩： 下一个 ��� 钩：每个动态导入表达式。[`renderStart`](https://rollupjs.org/guide/en/#renderstart)
[`renderDynamicImport`](https://rollupjs.org/guide/en/#renderdynamicimport)

cf. [`output.banner/output.footer`](https://rollupjs.org/guide/en/#outputbanneroutputfooter)。

### `closeBundle`

类型：`closeBundle: () => Promise<void> | void`
种类：`async, parallel`
上一个挂钩：[`buildEnd`](https://rollupjs.org/guide/en/#buildend)如果存在构建错误，否则[`bundle.close()`](https://rollupjs.org/guide/en/#rolluprollup)调用时，在这种情况下，这将是最后一个要触发的挂钩。

可用于清除可能正在运行的任何外部服务。Rollup 的 CLI 将确保在每次运行后都调用此钩子，但是 JavaScript API 的用户有责任`bundle.close()`在完成生成捆绑包后手动对其进行调用。因此，任何依赖此功能的插件都应在其文档中仔细提及。

如果插件希望在监视模式下跨构建保留资源，则可以[`this.meta.watchMode`](https://rollupjs.org/guide/en/#thismeta-rollupversion-string-watchmode-boolean)在此挂钩中进行检查并在中对监视模式执行必要的清理[`closeWatcher`](https://rollupjs.org/guide/en/#closewatcher)。

### `footer`

类型：`string | (() => string)`
类型：`async, parallel`
上一个挂钩： 下一个挂钩：每个动态导入表达式。[`renderStart`](https://rollupjs.org/guide/en/#renderstart)
[`renderDynamicImport`](https://rollupjs.org/guide/en/#renderdynamicimport)

cf. [`output.banner/output.footer`](https://rollupjs.org/guide/en/#outputbanneroutputfooter)。

### `generateBundle`

类型：`(options: OutputOptions, bundle: { [fileName: string]: AssetInfo | ChunkInfo }, isWrite: boolean) => void`
种类：`async, sequential`
上一个挂钩：[`renderChunk`](https://rollupjs.org/guide/en/#renderchunk)每个块。
下一个挂钩：[`writeBundle`](https://rollupjs.org/guide/en/#writebundle)如果输出是通过生成的`bundle.write(...)`，否则这是输出生成阶段的最后一个挂钩，并且[`outputOptions`](https://rollupjs.org/guide/en/#outputoptions)如果生成了另一个输出，则可能再次跟随该挂钩。

在`bundle.generate()`文件写入结束时或之前立即调用`bundle.write()`。要在写入文件后对其进行修改，请使用[`writeBundle`](https://rollupjs.org/guide/en/#writebundle)钩子。`bundle`提供正在写入或生成的文件的完整列表以及它们的详细信息：

```js
// AssetInfo
{
  fileName: string,
  name?: string,
  source: string | Uint8Array,
  type: 'asset',
}

// ChunkInfo
{
  code: string,
  dynamicImports: string[],
  exports: string[],
  facadeModuleId: string | null,
  fileName: string,
  implicitlyLoadedBefore: string[],
  imports: string[],
  importedBindings: {[imported: string]: string[]},
  isDynamicEntry: boolean,
  isEntry: boolean,
  isImplicitEntry: boolean,
  map: SourceMap | null,
  modules: {
    [id: string]: {
      renderedExports: string[],
      removedExports: string[],
      renderedLength: number,
      originalLength: number
    },
  },
  name: string,
  referencedFiles: string[],
  type: 'chunk',
}
```

您可以通过从此挂钩中的捆绑对象中删除文件来防止文件被发出。要发出其他文件，请使用[`this.emitFile`](https://rollupjs.org/guide/en/#thisemitfileemittedfile-emittedchunk--emittedasset--string) 插件上下文功能。

### `intro`

类型：`string | (() => string)`
类型：`async, parallel`
上一个挂钩： 下一个挂钩：每个动态导入表达式。[`renderStart`](https://rollupjs.org/guide/en/#renderstart)
[`renderDynamicImport`](https://rollupjs.org/guide/en/#renderdynamicimport)

cf. [`output.intro/output.outro`](https://rollupjs.org/guide/en/#outputintrooutputoutro)。

### `outputOptions`

类型：`(outputOptions: OutputOptions) => OutputOptions | null`
种类：`sync, sequential`
上一个挂钩：[`buildEnd`](https://rollupjs.org/guide/en/#buildend)如果这是第一次生成输出，否则为[`generateBundle`](https://rollupjs.org/guide/en/#generatebundle)，[`writeBundle`](https://rollupjs.org/guide/en/#writebundle)或者[`renderError`](https://rollupjs.org/guide/en/#rendererror)取决于之前生成的输出。这是输出生成阶段的第一个钩子。
下一个挂钩：[`renderStart`](https://rollupjs.org/guide/en/#renderstart)。

替换或操纵传递给`bundle.generate()`或的输出选项对象`bundle.write()`。退货`null`不会替代任何东西。如果只需要阅读输出选项，则建议使用该[`renderStart`](https://rollupjs.org/guide/en/#renderstart)挂钩，因为`outputOptions`在考虑了所有挂钩的转换之后，该挂钩可以访问输出选项。

### `outro`

类型：`string | (() => string)`
类型：`async, parallel`
上一个挂钩： 下一个挂钩：每个动态导入表达式。[`renderStart`](https://rollupjs.org/guide/en/#renderstart)
[`renderDynamicImport`](https://rollupjs.org/guide/en/#renderdynamicimport)

cf. [`output.intro/output.outro`](https://rollupjs.org/guide/en/#outputintrooutputoutro)。

### `renderChunk`

类型：`(code: string, chunk: ChunkInfo, options: OutputOptions) => string | { code: string, map: SourceMap } | null`
种类：`async, sequential`
上一个挂钩：[`resolveFileUrl`](https://rollupjs.org/guide/en/#resolvefileurl)用于的每次使用`import.meta.ROLLUP_FILE_URL_referenceId`以及[`resolveImportMeta`](https://rollupjs.org/guide/en/#resolveimportmeta)对的所有其他访问`import.meta`。
下一个挂钩：[`generateBundle`](https://rollupjs.org/guide/en/#generatebundle)。

可用于转换单个块。为每个汇总输出块文件调用。返回`null`将不应用任何转换。

### `renderDynamicImport`

类型：`({format: string, moduleId: string, targetModuleId: string | null, customResolution: string | null}) => {left: string, right: string} | null`
种类：`sync, first`
之前的符：[`banner`](https://rollupjs.org/guide/en/#banner)，[`footer`](https://rollupjs.org/guide/en/#footer)，[`intro`](https://rollupjs.org/guide/en/#intro)，[`outro`](https://rollupjs.org/guide/en/#outro)。
下一个挂钩：[`augmentChunkHash`](https://rollupjs.org/guide/en/#augmentchunkhash)对于每个在文件名中包含哈希的块。

该挂钩通过在 import 表达式的参数的左（`import(`）和右（`)`）处提供代码替换来提供对如何呈现动态导入的细粒度控制。`null`将延迟返回到此类型的其他挂钩，并最终呈现特定于格式的默认值。

`format`是呈现的输出格式，`moduleId`即执行动态导入的模块的 ID。如果可以将导入解析为内部或外部 ID，`targetModuleId`则将其设置为该 ID，否则为`null`。如果动态导入包含一个非字符串表达式，该表达式由一个[`resolveDynamicImport`](https://rollupjs.org/guide/en/#resolvedynamicimport)钩子替换为替换字符串，则`customResolution`它将包含该字符串。

以下代码将用自定义处理程序替换所有动态导入，并添加`import.meta.url`第二个参数以允许处理程序正确解析相对导入：

```js
// plugin
const plugin = {
  name: 'dynamic-import-polyfill',
  renderDynamicImport() {
    return {
      left: 'dynamicImportPolyfill(',
      right: ', import.meta.url)',
    }
  },
}

// input
import('./lib.js')

// output
dynamicImportPolyfill('./lib.js', import.meta.url)
```

下一个插件将确保的所有动态导入`esm-lib`都标记为外部，并保留为导入表达式，例如，允许 CommonJS 构建在 Node 13+中导入 ES 模块，请参见。如何[从](https://nodejs.org/api/esm.html#esm_import_expressions)Node 文档中的[CommonJS 导入 ES 模块](https://nodejs.org/api/esm.html#esm_import_expressions)。

```js
// plugin
const plugin = {
  name: 'retain-import-expression',
  resolveDynamicImport(specifier) {
    if (specifier === 'esm-lib') return false
    return null
  },
  renderDynamicImport({ targetModuleId }) {
    if (targetModuleId === 'esm-lib')
      return {
        left: 'import(',
        right: ')',
      }
  },
}
```

请注意，当该钩子以非 ES 格式重写动态导入时，没有互操作代码可确保`.default`生 �� 默认的导出，例如默认导出。插件负责确保重写的动态导入返回一个 Promise，该 Promise 可以解析为正确的名称空间对象。

### `renderError`

类型：`(error: Error) => void`
种类：`async, parallel`
上一个挂钩：从[`renderStart`](https://rollupjs.org/guide/en/#renderstart)到的任何挂钩[`renderChunk`](https://rollupjs.org/guide/en/#renderchunk)。
下一个挂钩：如果被调用，这是输出生成阶段的最后一个挂钩，[`outputOptions`](https://rollupjs.org/guide/en/#outputoptions)如果生成另一个输出，则可能再次跟随。

当汇总在`bundle.generate()`或期间遇到错误时调用`bundle.write()`。错误传递给该钩子。要在生成成功完成时得到通知，请使用`generateBundle`钩子。

### `renderStart`

类型：`(outputOptions: OutputOptions, inputOptions: InputOptions) => void`
种类：`async, parallel`
之前的符： 一个钩子：，，和并行运行。[`outputOptions`](https://rollupjs.org/guide/en/#outputoptions)
[`banner`](https://rollupjs.org/guide/en/#banner)[`footer`](https://rollupjs.org/guide/en/#footer)[`intro`](https://rollupjs.org/guide/en/#intro)[`outro`](https://rollupjs.org/guide/en/#outro)

初次调用`bundle.generate()`或被`bundle.write()`调用。要在生成完成时得到通知，请使用`generateBundle`和`renderError`钩子。这是推荐的钩子，当你需要访问传递到输出选项使用`bundle.generate()`或`bundle.write()`因为它需要由所有转换[`outputOptions`](https://rollupjs.org/guide/en/#outputoptions)挂钩考虑，并且还包含了未设置选项正确的默认值。它还接收传递给的输入选项，`rollup.rollup()`以便可用作输出插件的插件（即仅使用`generate`阶段挂钩的插件）可以访问它们。

### `resolveFileUrl`

类型：`({chunkId: string, fileName: string, format: string, moduleId: string, referenceId: string, relativePath: string}) => string | null`
种类：`sync, first`
上一个挂钩：[`augmentChunkHash`](https://rollupjs.org/guide/en/#augmentchunkhash)对于文件名中将包含哈希的每个块。
下一个挂钩：[`renderChunk`](https://rollupjs.org/guide/en/#renderchunk)每个块。

允许自定义汇总功能如何解析插件通过发出的文件的 URL `this.emitFile`。默认情况下，汇总将为其生成代码，`import.meta.ROLLUP_FILE_URL_referenceId`该代码应正确生成发射文件的绝对 URL，而与输出格式和代码所在的主机系统无关。

对于这一点，除了 CommonJS 的和 UMD 格式都认为他们在浏览器环境下运行`URL`并`document`可用。万一失败或生成更多优化的代码，则可以使用此挂钩自定义此行为。为此，可以使用以下信息：

- `chunkId`：引用此文件的块的 ID。
- `fileName`：相对于`output.dir`没有前导的发射资产的路径和文件名`./`。
- `format`：呈现的输出格式。
- `moduleId`：引用此文件的原始模块的 ID。对于有条件地以不同方式解决某些资产很有用。
- `referenceId`：文件的参考 ID。
- `relativePath`：相对于从中引用文件的块，所发出文件的路径和文件名。此路径将不包含任何前导，`./`但可能包含一个前导`../`。

请注意，由于此钩子可以访问当前块的文件名，因此在生成此块的哈希值时将不考虑其返回值。

以下插件将始终解析与当前文档相关的所有文件：

```js
// rollup.config.js
resolveFileUrl({fileName}) {
  return `new URL('${fileName}', document.baseURI).href`;
}
```

### `resolveImportMeta`

类型：`(property: string | null, {chunkId: string, moduleId: string, format: string}) => string | null`
种类：`sync, first`
上一个挂钩：[`augmentChunkHash`](https://rollupjs.org/guide/en/#augmentchunkhash)对于文件名中将包含哈希的每个块。
下一个挂钩：[`renderChunk`](https://rollupjs.org/guide/en/#renderchunk)每个块。

允许自定义汇总如何处理`import.meta`和`import.meta.someProperty`特别`import.meta.url`。在 ES 模块中，`import.meta`是一个对象，`import.meta.url`包含当前模块的 URL，例如，`http://server.net/bundle.js`对于浏览器或`file:///path/to/bundle.js`在 Node 中。

默认情况下，对于 ES 模块以外的格式，汇总会`import.meta.url`通过返回当前块的动态 URL 来尝试匹配此行为的代码替换。请注意，除了 CommonJS 的和 UMD 格式都认为他们在浏览器环境下运行`URL`并`document`可用。对于其他属性，`import.meta.someProperty`将其替换为`undefined`while ，而`import.meta`将其替换为包含`url`属性的对象。

通过此钩子，可以更改此行为（对于 ES 模块也可以更改）。对于每次出现`import.meta<.someProperty>`，都会使用属性名称或直接访问`null`if`import.meta`来调用此挂钩。例如，以下代码将`import.meta.url`使用原始模块到当前工作目录的相对路径来解析，并在运行时针对当前文档的基础 URL 再次解析该路径：

```js
// rollup.config.js
resolveImportMeta(property, {moduleId}) {
  if (property === 'url') {
    return `new URL('${path.relative(process.cwd(), moduleId)}', document.baseURI).href`;
  }
  return null;
}
```

请注意，由于此钩子可以访问当前块的文件名，因此在生成此块的哈希值时将不考虑其返回值。

### `writeBundle`

类型：`(options: OutputOptions, bundle: { [fileName: string]: AssetInfo | ChunkInfo }) => void`
种类：`async, parallel`
上一个挂钩： 下一个挂钩：如果被调用，这是输出生成阶段的最后一个挂钩，如果生成另一个输出，则可能会再次跟随。[`generateBundle`](https://rollupjs.org/guide/en/#generatebundle)
[`outputOptions`](https://rollupjs.org/guide/en/#outputoptions)

`bundle.write()`所有文件写入完毕后才调用。与[`generateBundle`](https://rollupjs.org/guide/en/#generatebundle)挂钩类似，`bundle`它提供了要写入的文件的完整列表以及它们的详细信息。

## 不推荐使用的挂钩

These️ 这些钩子已被弃用，并可能在将来的汇总版本中删除。

- `resolveAssetUrl`-**_使用[`resolveFileUrl`](https://rollupjs.org/guide/en/#resolvefileurl)_**-功能挂钩，可用于自定义资产 URL 的生成代码。

将来有必要时，可能会支持更多属性。

## 插件上下文

可以从大多数[挂钩中](https://rollupjs.org/guide/en/#build-hooks)通过`this`以下方式访问许多实用程序功能和信息位：

### `this.addWatchFile(id: string) => void`

添加要在监视模式下监视的其他文件，以便对这些文件进行更改将触发重建。`id`可以是文件或目录的绝对路径，也可以是相对于当前工作目录的路径。这个上下文函数只能在钩在构建阶段被使用，即在`buildStart`，`load`，`resolveId`，和`transform`。

**注意：**通常在监视模式下以提高重建速度，`transform`仅当给定模块的内容实际更改时，才会为该模块触发该挂钩。如果监视的文件发生更改`this.addWatchFile`，则在`transform`挂钩中使用 from 可以确保`transform`也重新评估了此模块的挂钩。

通常，建议`this.addWatchFile`从依赖于监视文件的挂钩中使用。

### `this.emitFile(emittedFile: EmittedChunk | EmittedAsset) => string`

发出一个新文件，该文件包含在构建输出中，并返回一个`referenceId`，可以在各个地方使用它来引用发出的文件。`emittedFile`可以具有以下两种形式之一：

```js
// EmittedChunk
{
  type: 'chunk',
  id: string,
  name?: string,
  fileName?: string,
  implicitlyLoadedAfterOneOf?: string[],
  importer?: string,
  preserveSignature?: 'strict' | 'allow-extension' | 'exports-only' | false,
}

// EmittedAsset
{
  type: 'asset',
  name?: string,
  fileName?: string,
  source?: string | Uint8Array
}
```

在这两种情况下，都可以提供 a`name`或 a `fileName`。如果`fileName`提供了 a ，则将其未经修改地用作生成文件的名称，如果这会导致冲突，则引发错误。否则，如果`name`提供了 a ，它将用作`[name]`对应的[`output.chunkFileNames`](https://rollupjs.org/guide/en/#outputchunkfilenames)或[`output.assetFileNames`](https://rollupjs.org/guide/en/#outputassetfilenames)模式中的替代，可能在文件名的末尾添加一个唯一的编号以避免冲突。如果既未提供`name`no 也未`fileName`提供，则将使用默认名称。

您可以通过[`load`](https://rollupjs.org/guide/en/#load)或[`transform`](https://rollupjs.org/guide/en/#transform)插件挂钩返回的任何代码引用发射文件的 URL `import.meta.ROLLUP_FILE_URL_referenceId`。有关更多详细信息和示例，请参见[文件 URL](https://rollupjs.org/guide/en/#file-urls)。

`import.meta.ROLLUP_FILE_URL_referenceId`可以通过[`resolveFileUrl`](https://rollupjs.org/guide/en/#resolvefileurl)插件挂钩自定义替换的生成代码。您还可以使用它[`this.getFileName(referenceId)`](https://rollupjs.org/guide/en/#thisgetfilenamereferenceid-string--string)来确定文件名

如果`type`是*`chunk`*，则它将以给定模块`id`为入口点发出一个新块。要解决该问题，`id`它将像常规入口点一样通过 build 挂钩传递，以开头[`resolveId`](https://rollupjs.org/guide/en/#resolveid)。如果`importer`提供，则它用作的第二个参数，`resolveId`对于正确解析相对路径很重要。如果未提供，将相对于当前工作目录解析路径。如果提供了的值`preserveSignature`，则将[`preserveEntrySignatures`](https://rollupjs.org/guide/en/#preserveentrysignatures)对此特定的块覆盖。

这不会导致图中的模块重复，相反，如有必要，将拆分现有的块或创建具有重新导出功能的外观块。具有指定块的块`fileName`将始终生成单独的块，而其他发出的块可能会与现有块进行重复数据删除，即使它们`name`不匹配。如果未对此类数据块进行重复数据删除，[`output.chunkFileNames`](https://rollupjs.org/guide/en/#outputchunkfilenames)则将使用名称模式。

默认情况下，汇总假定发射的块是独立于其他入口点执行的，甚至可能在执行任何其他代码之前也是如此。这意味着，如果发出的块与现有入口点共享依赖关系，则汇总将为在这些入口点之间共享的依赖关系创建一个附加块。提供模块 ID 的非空数组`implicitlyLoadedAfterOneOf`将通过为 Rollup 提供其他信息来防止这种情况的发生，从而改变该行为。这些 ID 将以与`id`属性相同的方式解析，并会尊重该`importer`属性（如果提供）。现在，汇总将假定仅在导致以下项中的一个 ID 的入口点中至少有一个入口点时才执行所发出的块`implicitlyLoadedAfterOneOf`正在执行要加载的程序，创建了相同的程序块，就像新发出的程序块只能通过从中的模块动态导入来访问一样`implicitlyLoadedAfterOneOf`。这是一个使用此示例创建带有几个脚本的简单 HTML 文件，创建优化块以遵守其执行顺序的示例：

```js
// rollup.config.js
function generateHtml() {
  let ref1, ref2, ref3
  return {
    buildStart() {
      ref1 = this.emitFile({
        type: 'chunk',
        id: 'src/entry1',
      })
      ref2 = this.emitFile({
        type: 'chunk',
        id: 'src/entry2',
        implicitlyLoadedAfterOneOf: ['src/entry1'],
      })
      ref3 = this.emitFile({
        type: 'chunk',
        id: 'src/entry3',
        implicitlyLoadedAfterOneOf: ['src/entry2'],
      })
    },
    generateBundle() {
      this.emitFile({
        type: 'asset',
        fileName: 'index.html',
        source: `
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="UTF-8">
        <title>Title</title>
       </head>
      <body>
        <script src="${this.getFileName(ref1)}" type="module"></script>
        <script src="${this.getFileName(ref2)}" type="module"></script>
        <script src="${this.getFileName(ref3)}" type="module"></script>
      </body>
      </html>
      `,
      })
    },
  }
}

export default {
  input: [],
  preserveEntrySignatures: false,
  plugins: [generateHtml()],
  output: {
    format: 'es',
    dir: 'dist',
  },
}
```

如果没有动态导入，则将创建三个块，其中第一个块包含的所有依赖项`src/entry1`，第二个块仅`src/entry2`包含第一个块中未包含的依赖项，从第一个块中导入那些依赖项，然后再次导入相同的依赖项第三块

请注意，即使可以在其中使用任何模块 id `implicitlyLoadedAfterOneOf`，如果无法将此类 id 唯一地与块关联，例如，因为`id`不能从现有的静态入口点隐式或显式地访问该代码，则 Rollup 也会引发错误。完全摇摇欲坠。但是，仅使用由用户定义的入口点或先前发出的块的入口点将始终有效。

如果`type`is 为*`asset`*，则它将发出一个以给定`source`的内容为内容的任意新文件。可以将`source`通孔的设置推迟[`this.setAssetSource(referenceId, source)`](https://rollupjs.org/guide/en/#thissetassetsourcereferenceid-string-source-string--uint8array--void)到以后的时间，以便能够在构建阶段引用文件，同时在生成阶段为每个输出分别设置源。具有指定资源的资产`fileName`将始终生成单独的文件，而其他发出的资产可能会与现有资产进行重复数据删除，即使它们具有相同的来源，即使它们`name`不匹配也是如此。如果未对此类资产进行重复数据删除，[`output.assetFileNames`](https://rollupjs.org/guide/en/#outputassetfilenames)则将使用名称模式。

### `this.error(error: string | Error, position?: number | { column: number; line: number }) => never`

在结构上等同于`this.warn`，不同之处在于它还会中止捆绑过程。

### `this.getCombinedSourcemap() => SourceMap`

获取所有先前插件的组合源地图。此上下文函数只能在[`transform`](https://rollupjs.org/guide/en/#transform)插件挂钩中使用。

### `this.getFileName(referenceId: string) => string`

获取通过发出的块或资产的文件名[`this.emitFile`](https://rollupjs.org/guide/en/#thisemitfileemittedfile-emittedchunk--emittedasset--string)。文件名将相对于`outputOptions.dir`。

### `this.getModuleIds() => IterableIterator<string>`

返回一个`Iterator`，可以访问当前图形中的所有模块 ID。可以通过迭代

```js
for (const moduleId of this.getModuleIds()) {
  /* ... */
}
```

或通过转换为 Array `Array.from(this.getModuleIds())`。

### `this.getModuleInfo(moduleId: string) => (ModuleInfo | null)`

以表格形式返回有关该模块的其他信息

```js
{
  id: string, // the id of the module, for convenience
  code: string | null, // the source code of the module, `null` if external or not yet available
  ast: ESTree.Program, // the parsed abstract syntax tree if available
  isEntry: boolean, // is this a user- or plugin-defined entry point
  isExternal: boolean, // for external modules that are referenced but not included in the graph
  importedIds: string[], // the module ids statically imported by this module
  importers: string[], // the ids of all modules that statically import this module
  dynamicallyImportedIds: string[], // the module ids imported by this module via dynamic import()
  dynamicImporters: string[], // the ids of all modules that import this module via dynamic import()
  implicitlyLoadedAfterOneOf: string[], // implicit relationships, declared via this.emitChunk
  implicitlyLoadedBefore: string[], // implicit relationships, declared via this.emitChunk
  hasModuleSideEffects: boolean | "no-treeshake" // are imports of this module included if nothing is imported from it
  meta: {[plugin: string]: any} // custom module meta-data
  syntheticNamedExports: boolean | string // final value of synthetic named exports
}
```

在构建期间，此对象表示有关模块的当前可用信息。在执行[`buildEnd`](https://rollupjs.org/guide/en/#buildend)钩子操作之前，此信息可能不完整，例如`importedIds`尚未解决或`importers`发现了其他信息。

返回`null`是否找不到模块 ID。

### `this.getWatchFiles() => string[]`

获取以前观看过的文件的 ID。包括`this.addWatchFile`在构建期间由插件添加的文件和由汇总隐式添加的文件。

### `this.meta: {rollupVersion: string, watchMode: boolean}`

包含潜在有用的汇总元数据的对象：

- `rollupVersion`：在中定义的当前运行的汇总版本`package.json`。
- `watchMode`：`true`如果汇总是通过`rollup.watch(...)`或从命令行使用来启动的`--watch`，`false`否则。

`meta`是从[`options`](https://rollupjs.org/guide/en/#options)挂钩访问的唯一上下文属性。

### `this.parse(code: string, acornOptions?: AcornOptions) => ESTree.Program`

使用汇总的内部橡子实例将代码解析为 AST。

### `this.resolve(source: string, importer?: string, options?: {skipSelf?: boolean, custom?: {[plugin: string]: any}}) => Promise<{id: string, external: boolean, moduleSideEffects: boolean | 'no-treeshake', syntheticNamedExports: boolean | string, meta: {[plugin: string]: any}} | null>`

使用 Rollup 使用的相同插件将导入解析为模块 ID（即文件名），并确定导入是否应该是外部的。如果`null`返回，则导入无法由 Rollup 或任何插件解决，但未被用户显式标记为外部。

如果通过`skipSelf: true`，则在解析时将跳过`resolveId`从其`this.resolve`调用的插件的钩子。

您还可以通过选项传递特定于插件的选项的对象，有关详细信息`custom`，请参见[自定义解析器选项](https://rollupjs.org/guide/en/#custom-resolver-options)。

### `this.setAssetSource(referenceId: string, source: string | Uint8Array) => void`

设置资产的递延来源。请注意，您也可以传递 Node `Buffer`，`source`因为它是的子类`Uint8Array`。

### `this.warn(warning: string | RollupWarning, position?: number | { column: number; line: number }) => void`

使用此方法将使构建警告排队。这些警告将像内部生成的警告一样（由插件名称除外）由 CLI 打印，或由自定义`onwarn`处理程序捕获。

所述`warning`参数可以是`string`或具有（至少）一个对象`message`属性：

```js
this.warn('hmm...')
// is equivalent to
this.warn({ message: 'hmm...' })
```

如果需要向警告对象添加其他属性，请使用第二种形式。汇总将使用`plugin`包含插件名称，`code`（`PLUGIN_WARNING`）和`id`（正在转换的文件）属性的属性来扩大警告对象。

该`position`参数是哪里引发的警告字符索引。如果存在，汇总将使用`pos`，`loc`（一个标准`{ file, line, column }`对象）和`frame`（一个显示错误的代码片段）扩充警告对象。

## 不推荐使用的上下文函数

context️ 这些上下文实用程序功能已被弃用，并可能在将来的汇总版本中删除。

- `this.emitAsset(assetName: string, source: string) => string`-**_使用[`this.emitFile`](https://rollupjs.org/guide/en/#thisemitfileemittedfile-emittedchunk--emittedasset--string)_**-发出包含在构建输出中的自定义文件，并返回一个`referenceId`可用于引用发出的文件的文件。如果稍后通过提供，则可以推迟设置源[`this.setAssetSource(referenceId, source)`](https://rollupjs.org/guide/en/#thissetassetsourcereferenceid-string-source-string--uint8array--void)。必须通过任一方法为每个资产设置字符串或`Uint8Array`/`Buffer`源，否则在生成完成时将引发错误。

  发出的资产将遵循[`output.assetFileNames`](https://rollupjs.org/guide/en/#outputassetfilenames)命名方案。您可以通过[`load`](https://rollupjs.org/guide/en/#load)或[`transform`](https://rollupjs.org/guide/en/#transform)插件挂钩返回的任何代码引用文件的 URL `import.meta.ROLLUP_ASSET_URL_referenceId`。

  `import.meta.ROLLUP_ASSET_URL_referenceId`可以通过[`resolveFileUrl`](https://rollupjs.org/guide/en/#resolvefileurl)插件挂钩自定义替换的生成代码。在期间完成资产的确定后`generate`，您还可以使用[`this.getFileName(referenceId)`](https://rollupjs.org/guide/en/#thisgetfilenamereferenceid-string--string)来确定文件名。

- `this.emitChunk(moduleId: string, options?: {name?: string}) => string`-**_使用[`this.emitFile`](https://rollupjs.org/guide/en/#thisemitfileemittedfile-emittedchunk--emittedasset--string)_**-**_使用_**给定的模块作为入口点发出新的块。这不会导致图中的模块重复，相反，如有必要，将拆分现有的块。它返回一个`referenceId`，可用于以后访问块的已生成文件名。

  发射块将遵循[`output.chunkFileNames`](https://rollupjs.org/guide/en/#outputchunkfilenames)，[`output.entryFileNames`](https://rollupjs.org/guide/en/#outputentryfilenames)命名方案。如果`name`提供 a，则将其用作`[name]`文件名占位符，否则名称将从文件名派生。如果`name`提供 a，则该名称不得与任何其他入口点名称冲突，除非入口点引用相同的入口模块。您可以通过[`load`](https://rollupjs.org/guide/en/#load)或[`transform`](https://rollupjs.org/guide/en/#transform)插件挂钩返回的任何代码引用发出的块的 URL `import.meta.ROLLUP_CHUNK_URL_referenceId`。

  `import.meta.ROLLUP_CHUNK_URL_referenceId`可以通过[`resolveFileUrl`](https://rollupjs.org/guide/en/#resolvefileurl)插件挂钩自定义替换的生成代码。在期间渲染块之后`generate`，您还可以使用[`this.getFileName(referenceId)`](https://rollupjs.org/guide/en/#thisgetfilenamereferenceid-string--string)来确定文件名。

- `this.getAssetFileName(referenceId: string) => string`-**_使用[`this.getFileName`](https://rollupjs.org/guide/en/#thisgetfilenamereferenceid-string--string)_**-根据`assetFileNames`输出选项模式获取资产的文件名。文件名将相对于`outputOptions.dir`。

- `this.getChunkFileName(referenceId: string) => string`-**_使用[`this.getFileName`](https://rollupjs.org/guide/en/#thisgetfilenamereferenceid-string--string)_**-获取发出的块的文件名。文件名将相对于`outputOptions.dir`。

- `this.isExternal(id: string, importer: string | undefined, isResolved: boolean) => boolean`-**_使用[`this.resolve`](https://rollupjs.org/guide/en/#thisresolvesource-string-importer-string-options-skipself-boolean-custom-plugin-string-any--promiseid-string-external-boolean-modulesideeffects-boolean--no-treeshake-syntheticnamedexports-boolean--string-meta-plugin-string-any--null)_**-确定由导入时给定的模块 ID 是否为外部`importer`。如果`isResolved`为 false，则 Rollup 将在测试 ID 是否为外部之前尝试解析 ID。

- `this.moduleIds: IterableIterator<string>`-**_使用[`this.getModuleIds`](https://rollupjs.org/guide/en/#thisgetmoduleids--iterableiteratorstring)_**-`Iterator`提供对当前图形中所有模块 ID 的访问权限的。可以通过迭代

  ```js
  for (const moduleId of this.moduleIds) {
    /* ... */
  }
  ```

  或通过转换为 Array `Array.from(this.moduleIds)`。

- `this.resolveId(source: string, importer?: string) => Promise<string | null>`-**_使用[`this.resolve`](https://rollupjs.org/guide/en/#thisresolvesource-string-importer-string-options-skipself-boolean-custom-plugin-string-any--promiseid-string-external-boolean-modulesideeffects-boolean--no-treeshake-syntheticnamedexports-boolean--string-meta-plugin-string-any--null)_**-使用 Rollup 使用的相同插件，将导入解析为模块 ID（即文件名）。`null`如果无法解析 ID，则返回。

## 档案网址

要从 JS 代码中引用文件 URL 引用，请使用`import.meta.ROLLUP_FILE_URL_referenceId`替换。这将生成取决于输出格式的代码，并生成指向目标环境中发出的文件的 URL。请注意，除了 CommonJS 的和 UMD 格式都认为他们在浏览器环境下运行`URL`并`document`可用。

以下示例将检测`.svg`文件的导入，将导入的文件作为资产发出，并返回其 URL 以用作例如标记的`src`属性`img`：

```js
// plugin
export default function svgResolverPlugin() {
  return {
    resolveId(source, importer) {
      if (source.endsWith('.svg')) {
        return path.resolve(path.dirname(importer), source)
      }
    },
    load(id) {
      if (id.endsWith('.svg')) {
        const referenceId = this.emitFile({
          type: 'asset',
          name: path.basename(id),
          source: fs.readFileSync(id),
        })
        return `export default import.meta.ROLLUP_FILE_URL_${referenceId};`
      }
    },
  }
}
```

用法：

```js
import logo from '../images/logo.svg'
const image = document.createElement('img')
image.src = logo
document.body.appendChild(image)
```

与资产类似，发出的块也可以通过 JS 代码来引用`import.meta.ROLLUP_FILE_URL_referenceId`。

以下示例将检测带有前缀的导入，`register-paint-worklet:`并生成必要的代码和单独的块，以生成 CSS Paint Worklet。请注意，这仅在现代浏览器中有效，并且仅在将输出格式设置为时才有效`es`。

```js
// plugin
const REGISTER_WORKLET = 'register-paint-worklet:'
export default function paintWorkletPlugin() {
  return {
    load(id) {
      if (id.startsWith(REGISTER_WORKLET)) {
        return `CSS.paintWorklet.addModule(import.meta.ROLLUP_FILE_URL_${this.emitFile(
          {
            type: 'chunk',
            id: id.slice(REGISTER_WORKLET.length),
          }
        )});`
      }
    },
    resolveId(source, importer) {
      // We remove the prefix, resolve everything to absolute ids and add the prefix again
      // This makes sure that you can use relative imports to define worklets
      if (source.startsWith(REGISTER_WORKLET)) {
        return this.resolve(
          source.slice(REGISTER_WORKLET.length),
          importer
        ).then(resolvedId => REGISTER_WORKLET + resolvedId.id)
      }
      return null
    },
  }
}
```

用法：

```js
// main.js
import 'register-paint-worklet:./worklet.js'
import { color, size } from './config.js'
document.body.innerHTML += `<h1 style="background-image: paint(vertical-lines);">color: ${color}, size: ${size}</h1>`

// worklet.js
import { color, size } from './config.js'
registerPaint(
  'vertical-lines',
  class {
    paint(ctx, geom) {
      for (let x = 0; x < geom.width / size; x++) {
        ctx.beginPath()
        ctx.fillStyle = color
        ctx.rect(x * size, 0, 2, geom.height)
        ctx.fill()
      }
    }
  }
)

// config.js
export const color = 'greenyellow'
export const size = 6
```

如果您构建此代码，则主要块和工作集都将`config.js`通过共享块来共享代码。这使我们能够利用浏览器缓存来减少传输的数据并加快加载工作集的速度。

## 变形金刚

Transformer 插件（即返回`transform`例如编译非 JS 文件的函数的插件）应支持`options.include`和`options.exclude`，两者都可以是 minimatch 模式或 minimatch 模式数组。如果`options.include`省略或长度为零，则默认情况下应包括文件；否则，默认为 0。否则，仅当 ID 与模式之一匹配时才应包括它们。

的`transform`钩，如果返回的对象，还可以包括`ast`属性。仅在知道自己在做什么时才使用此功能。请注意，将仅使用转换链中的最后一个 AST（并且，如果存在转换，则由`load`挂钩生成的所有 AST 将被丢弃以用于转换后的模块。）

### 范例变压器

（将[@ rollup / pluginutils](https://github.com/rollup/plugins/tree/master/packages/pluginutils)用于常用功能，并以推荐的方式实现转换器。）

```js
import { createFilter } from '@rollup/pluginutils'

export default function myPlugin(options = {}) {
  const filter = createFilter(options.include, options.exclude)

  return {
    transform(code, id) {
      if (!filter(id)) return

      // proceed with the transformation...
      return {
        code: generatedCode,
        map: generatedSourceMap,
      }
    },
  }
}
```

### 源代码转换

如果插件转换了源代码，则除非有特定的`sourceMap: false`选项，否则它应自动生成一个源映射。汇总仅关心`mappings`属性（其他所有内容将自动处理）。如果生成源地图没有任何意义（例如[rollup-plugin-string](https://github.com/TrySound/rollup-plugin-string)），则返回一个空的源地图：

```js
return {
  code: transformedCode,
  map: { mappings: '' },
}
```

如果转换不移动代码，则可以通过返回`null`以下内容来保留现有的源地图：

```js
return {
  code: transformedCode,
  map: null,
}
```

如果您创建了一个您认为对其他人有用的插件，请将其发布到 NPM 并将其添加到[github.com/rollup/awesome](https://github.com/rollup/awesome)！

## 综合命名的出口

它可以通过设置指定失踪出口后备出口`syntheticNamedExports`在模块选项[`resolveId`](https://rollupjs.org/guide/en/#resolveid)，[`load`](https://rollupjs.org/guide/en/#load)或[`transform`](https://rollupjs.org/guide/en/#transform)钩。如果将字符串值用于`syntheticNamedExports`，则此模块会将所有缺少的命名导出的分辨率回退到给定名称的命名导出的属性：

**dep.js：（`{syntheticNamedExports: '__synthetic'}`）**

```js
export const foo = 'explicit'
export const __synthetic = {
  foo: 'foo',
  bar: 'bar',
}
```

**main.js：**

```js
import { foo, bar, baz, __synthetic } from './dep.js'

// logs "explicit" as non-synthetic exports take precedence
console.log(foo)

// logs "bar", picking the property from __synthetic
console.log(bar)

// logs "undefined"
console.log(baz)

// logs "{foo:'foo',bar:'bar'}"
console.log(__synthetic)
```

当用作入口点时，将仅显示显式导出。合成后备输出，即`__synthetic`在示例中，不会显示的字符串值`syntheticNamedExports`。但是，如果值为`true`，则将显示默认导出。这是`syntheticNamedExports: true`和之间唯一的显着区别`syntheticNamedExports: 'default'`。

## 插件间通信

在某些时候，使用许多专用插件时，可能需要无关的插件才能在构建过程中交换信息。汇总有多种机制使之成为可能。

### 自定义解析器选项

假设您有一个插件，可以根据模块的导入方式将模块解析为不同的 ID。实现此目的的一种方法是在导入此模块时使用特殊的代理 ID，例如，`require("foo")`可以使用 ID 表示转译的 import via ，`foo?require=true`以便解析器插件知道这一点。

但是，这里的问题是，当传递给其他解析器时，此代理 ID 可能会或可能不会引起意外的副作用。此外，如果 id 是由插件创建的`A`，而解析是在插件中进行的`B`，则它会在这些插件之间创建一个依赖项，因此如果`A`没有，将无法使用`B`。

自定义解析器选项在此处提供了一种解决方案，允许在手动解析模块时为插件传递其他选项。如果不存在预期的目标插件，则会在不更改 id 的情况下发生，因此也不会损害其他插件正确解析模块的能力。

```js
function requestingPlugin() {
  return {
    name: 'requesting',
    async buildStart() {
      const resolution = await this.resolve('foo', undefined, {
        custom: { resolving: { specialResolution: true } },
      })
      console.log(resolution.id) // "special"
    },
  }
}

function resolvingPlugin() {
  return {
    name: 'resolving',
    resolveId(id, importer, { custom }) {
      if (custom.resolving?.specialResolution) {
        return 'special'
      }
      return null
    },
  }
}
```

请注意以下约定：应使用与解析插件的插件名称相对应的属性来添加自定义选项。解析插件负责指定它遵循哪些选项。

### 自定义模块元数据

插件可以具有能够通过自己和其他插件经由访问自定义的元数据注释模块[`resolveId`](https://rollupjs.org/guide/en/#resolveid)，[`load`](https://rollupjs.org/guide/en/#load)和[`transform`](https://rollupjs.org/guide/en/#transform)钩。此元数据应始终为 JSON.stringifyable，并将保留在缓存中（例如在监视模式下）。

```js
function annotatingPlugin() {
  return {
    name: 'annotating',
    transform(code, id) {
      if (thisModuleIsSpecial(code, id)) {
        return { meta: { annotating: { special: true } } }
      }
    },
  }
}

function readingPlugin() {
  let parentApi
  return {
    name: 'reading',
    buildEnd() {
      const specialModules = Array.from(this.getModuleIds()).filter(
        id => this.getModuleInfo(id).meta.annotating?.special
      )
      // do something with this list
    },
  }
}
```

请注意，在这种情况下，添加或修改数据的插件应使用与插件名称相对应的属性`annotating`。另一方面，任何插件都可以通过读取其他插件的所有元数据`this.getModuleInfo`。

如果多个插件添加元数据或将元数据添加到不同的挂钩中，则这些`meta`对象将被浅合并。这意味着，如果插件`first`添加`{meta: {first: {resolved: "first"}}}`在 resolveId 钩和`{meta: {first: {loaded: "first"}}}`在负载钩而插件`second`增加`{meta: {second: {transformed: "second"}}}`在`transform`钩，然后将得到的`meta`物体将是`{first: {loaded: "first"}, second: {transformed: "second"}}`。`resolveId`钩子的结果将被钩子的结果覆盖，`load`因为插件都将它们存储在其`first`顶层属性下。`transform`另一方面，另一个插件的数据将放置在其旁边。

### 直接插件通讯

对于任何其他类型的插件间通信，我们建议使用以下模式。请注意，`api`它将永远不会与任何即将到来的插件挂钩冲突。

```js
function parentPlugin() {
  return {
    name: 'parent',
    api: {
      //...methods and properties exposed for other plugins
      doSomething(...args) {
        // do something interesting
      }
    }
    // ...plugin hooks
  }
}

function dependentPlugin() {
  let parentApi;
  return {
    name: 'dependent',
    buildStart({ plugins }) {
      const parentName = 'parent';
      const parentPlugin = options.plugins
        .find(plugin => plugin.name === parentName);
      if (!parentPlugin) {
        // or handle this silently if it is optional
        throw new Error(`This plugin depends on the "${parentName}" plugin.`);
      }
      // now you can access the API methods in subsequent hooks
      parentApi = parentPlugin.api;
    }
    transform(code, id) {
      if (thereIsAReasonToDoSomething(id)) {
        parentApi.doSomething(id);
      }
    }
  }
}
```
