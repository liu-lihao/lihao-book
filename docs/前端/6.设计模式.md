# 设计模式

设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。

## 五个设计原则

**S – Single Responsibility Principle 单一职责原则**

- 一个程序只做好一件事
- 如果功能过于复杂就拆分开，每个部分保持独立

**O – OpenClosed Principle 开放/封闭原则**

- 对扩展开放，对修改封闭
- 增加需求时，扩展新代码，而非修改已有代码

**L – Liskov Substitution Principle 里氏替换原则**

- 子类能覆盖父类
- 父类能出现的地方子类就能出现

**I – Interface Segregation Principle 接口隔离原则**

- 保持接口的单一独立
- 类似单一职责原则，这里更关注接口

**D – Dependency Inversion Principle 依赖倒转原则**

- 面向接口编程，依赖于抽象而不依赖于具
- 使用方只关注接口而不关注具体类的实现

## 三种设计模式类型

**结构型模式（Structural Patterns）：** 通过识别系统中组件间的简单关系来简化系统的设计。

**创建型模式（Creational Patterns）：** 处理对象的创建，根据实际情况使用合适的方式创建对象。常规的对象创建方式可能会导致设计上的问题，或增加设计的复杂度。创建型模式通过以某种方式控制对象的创建来解决问题。

**行为型模式（Behavioral Patterns）：** 用于识别对象之间常见的交互模式并加以实现，如此，增加了这些交互的灵活性。

## 9 种前端常见的设计模式

### 1. 外观模式（Facade Pattern）

提供简单易用的API

缺点：不符合开闭原则，改起来麻烦。

### 2. 代理模式（Proxy Pattern）

不直接修改，找个中间商代理，由中间商保护目标。

缺点：加了层代理，会有额外开销。

### 3. 工厂模式（Factory Pattern）

实例化对象是，由厂家去控制实例化成哪个对象。我们只需关注结果即可。

缺点：添加新构造函数时复杂度高了点。

### 4. 单例模式（Singleton Pattern）

只 `new` 一个对象出来用，比如在 `Vue 2.x` 就是这样。

缺点：耦合度高、不太好单元测试

### 5. 策略模式（Strategy Pattern）

写个战术，以分别使用不同函数/参数。

```js
// 非策略模式，硬写
if (普通用户) {
    普通用户操作()
} else if (会员用户) {
    会员用户操作()
}
// 策略模式
const 我的策略 = {
    普通用户: 普通用户操作
    会员用户: 会员用户操作
}
我的策略[xx用户]();

```

缺点：函数可能会有点多

### 6. 迭代器模式（Iterator Pattern）

提供一种方法顺序一个聚合对象中各个元素

### 7. 观察者模式（Observer Pattern）

可以用 Vue 的 `watch` 表示

### 8. 发布-订阅模式（Publish/Subscribe Pattern）

可以用 `EventBus` 表示

### 9. 中介者模式（Mediator Pattern）

对象直接不直接沟通，通过中介。

缺点：复杂度高的话，导致中介会及其复杂

### 10. 访问者模式（Visitor Pattern）

不影响自身的前提下，可以随便提供其他逻辑，即添加插件。扩展好。

缺点：插件多了后果你知道的。
