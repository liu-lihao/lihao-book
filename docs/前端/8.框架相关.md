# 框架相关

## 写 React / Vue 项目时为什么要在列表组件中写 key？

> `key` 是给每一个 `vnode` 的唯一 `id` ,可以 **依靠key**, 更 **准确** , 更 **快** 的拿到 `oldVnode` 中对应的 `vnode` 节点。

在被循环节点/组件非常简单的情况下，不传 `key` 或传入 `index` 都会导致diff时作为 `sameVnode`，粗暴的进行节点复用，会增加额外的diff开销，也会丢失过渡效果。

但是在 **列表稳定** 的情况下，不使用 `key` 确实会更快一点。但是对于 **频繁更新** 使用 `key` ,减少diff开销，性能会更好一点。

结论：`key` 的作用是为了在diff算法执行时更快的找到对应的节点，提高diff速度。

## Virtual DOM 真的比操作原生 DOM 快吗？

这是一个性能 vs 可维护性的取舍。

但是优秀的 Virtual DOM 和 diff，在绝大多数会比操作原生 DOM 快。

> **对 React 的 Virtual DOM 的误解**
>
> React 从来没有说过 “React 比原生操作 DOM 快”。React 的基本思维模式是每次有变动就整个重新渲染整个应用。如果没有 Virtual DOM，简单来想就是直接重置 innerHTML。很多人都没有意识到，在一个大型列表所有数据都变了的情况下，重置 innerHTML 其实是一个还算合理的操作... 真正的问题是在 “全部重新渲染” 的思维模式下，即使只有一行数据变了，它也需要重置整个 innerHTML，这时候显然就有大量的浪费。

不要天真地以为 Virtual DOM 就是快，diff 不是免费的，batching 么 MVVM 也能做，而且最终 patch 的时候还不是要用原生 API。在我看来 Virtual DOM 真正的价值从来都不是性能，而是它

1.  为函数式的 UI 编程方式打开了大门；

2. 可以渲染到 DOM 以外的 backend，比如 ReactNative。

## 为什么 Vuex 的 mutation 和 Redux 的 reducer 中不能做异步操作

如果经常用React+Redux开发，那么就应该了解Redux的设计初衷。Redux的设计参考了Flux的模式，作者希望以此来实现时间旅行，保存应用的历史状态，实现应用状态的可预测。所以整个Redux都是函数式编程的范式，要求reducer是 **纯函数** 也是自然而然的事情，**使用纯函数才能保证相同的输入得到相同的输入，保证状态的可预测** 。所以Redux有三大原则：

* 单一数据源，也就是state
* state 是只读，Redux并没有暴露出直接修改state的接口，必须通过action来触发修改
* 使用纯函数来修改state，reducer必须是纯函数

## Vuex、Flux、Redux、Redux-saga、Dva、MobX 原理及对比

> [知乎：Vuex、Flux、Redux、Redux-saga、Dva、MobX](https://zhuanlan.zhihu.com/p/53599723)