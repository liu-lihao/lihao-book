# Day01

## JS数据类型，值是如何存储的

1. 基本类型：`Undefined`、`Null`、`Boolean`、`Number`、`String`、`Symbol`（ES6，独一无二）、`BigInt`（ES10，大数）。

    存储在 **栈(stack)** 。占据空间小，大小固定。

2. 引用类型：`Object`

    指针存储在 **栈(stack)** ，数据存储在 **堆(heap)** 。占据空间大，大小不固定。

## && 、 ||和!! 运算符

* `&&` ： 逻辑与，返回找到的第一个虚值，如果没有则返回最后一个真值。

* `||` ： 逻辑或，返回找到的第一个真值，如果没有则返回最后一个虚值。

* `!!` ：转 `Boolean` 类型。

## JS类型判断

* `typeof`
  * 可能返回：`object`/`number`/`string`/`boolean`/`function`/`undefined`/`symbol`/`bigint`
  * `typeof null` 返回 `object`

* `instanceof`
  * 通过判断对象的原型链中是不是能找到类型的 `prototype`。
  * 无法判断基本类型

* `constructor`
  * 可改，有时不太靠谱。
  
* `Object.prototype.toString.call()`
  * 比较靠谱
  * `Object.prototype.toString.call(null); // "[object Null]"`

## 如何区分普通函数和箭头函数

普通函数有 `prototype`，箭头函数没有。

## `undefined` 与 `undeclared` 的区别？

* `undefined`: 已在作用域中声明但还没有赋值的变量。可以取值。
* `undeclared`: 还没有在作用域中声明过的变量。取值会报错，但可以使用 `typeof`（返回 `undefined`）。

## 作用域和作用域链

* **作用域** ： 作用域是定义变量的区域，它有一套访问变量的规则，这套规则来管理浏览器引擎如何在当前作用域以及嵌套的作用域中根据变量（标识符）进行变量查找。

* **作用域链** ： 作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，我们可以访问到外层环境的变量和函数。

* 浏览器实现的`__proto__`，不是标准的规范，建议使用 `Object.getPrototypeOf()`，也可以使用 `p.constructor.prototype`的方式。

* 当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又 会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 `Object.prototype` 所以这就 是我们新建的对象为什么能够使用 `toString()` 等方法的原因。

## JavaScript 创建对象的几种方式？

1. **工厂模式** ：工厂模式的主要工作原理是用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。但是它有一个很大的问题就是创建出来的对象无法和某个类型联系起来，它只是简单的封装了复用代码，而没有建立起对象和类型间的关系。 

2. **构造函数模式** ：js 中每一个函数都可以作为构造函数，只要一个函数是通过 new 来调用的。执行构造函数首先会创建一个对象，然后将对象的原型指向构造函数的 prototype 属性，然后将执行上下文中的 this 指向这个对象，最后再执行整个函数，如果返回值不是对象，则返回新建的对象。因为 this 的值指向了新建的对象，因此我们可以使用 this 给对象赋值。构造函数模式相对于工厂模式的优点是，所创建的对象和构造函数建立起了联系，因此我们可以通过原型来识别对象的类型。但是构造函数存在一个缺点就是，造成了不必要的函数对象的创建，因为在 js 中函数也是一个对象，因此如果对象属性中如果包含函数的话，那么每次我们都会新建一个函数对象，浪费了不必要的内存空间，因为函数是所有的实例都可以通用的。 

3. **原型模式** ：因为每一个函数都有一个 prototype 属性，这个属性是一个对象，它包含了通过构造函数创建的所有实例都能共享的属性和方法。因此我们可以使用原型对象来添加公用属性和方法，从而实现代码的复用。这种方式相对于构造函数模式来说，解决了函数对象的复用问题。但是这种模式也存在一些问题，一个是没有办法通过传入参数来初始化值，另一个是如果存在一个引用类型如 Array 这样的值，那么所有的实例将共享一个对象，一个实例对引用类型值的改变会影响所有的实例。 

4. **组合使用构造函数模式和原型模式** ：这是创建自定义类型的最常见方式。因为构造函数模式和原型模式分开使用都存在一些问题，因此我们可以组合使用这两种模式，通过构造函数来初始化对象的属性，通过原型对象来实现函数方法的复用。这种方法很好的解决了两种模式单独使用时的缺点，但是有一点不足的就是，因为使用了两种不同的模式，所以对于代码的封装性不够好。 

5. **动态原型模式** ：这一种模式将原型方法赋值的创建过程移动到了构造函数的内部，通过对属性是否存在的判断，可以实现仅在第一次调用函数时对原型对象赋值一次的效果。这一种方式很好地对上面的混合模式进行了封装。 

6. **寄生构造函数模式** ：这一种模式和工厂模式的实现基本相同，我对这个模式的理解是，它主要是基于一个已有的类型，在实例化时对实例化的对象进行扩展。这样既不用修改原来的构造函数，也达到了扩展对象的目的。它的一个缺点和工厂模式一样，无法实现对象的识别。

## JavaScript 继承的几种实现方式？

1. **以原型链的方式来实现继承** ：但是这种实现方式存在的缺点是，在包含有引用类型的数据时，会被所有的实例对象所共享，容易造成修改的混乱。还有就是在创建子类型的时候不能向超类型传递参数。

2. **使用借用构造函数的方式** ：这种方式是通过在子类型的函数中调用超类型的构造函数来实现的，这一种方法解决了不能向超类型传递参数的缺点，但是它存在的一个问题就是无法实现函数方法的复用，并且超类型原型定义的方法子类型也没有办法访问到。

3. **组合继承** ：组合继承是将原型链和借用构造函数组合起来使用的一种方式。通过借用构造函数的方式来实现类型的属性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。这种方式解决了上面的两种模式单独使用时的问题，但是由于我们是以超类型的实例来作为子类型的原型，所以调用了两次超类的构造函数，造成了子类型的原型中多了很多不必要的属性。

4. **原型式继承** ：原型式继承的主要思路就是基于已有的对象来创建新的对象，实现的原理是，向函数中传入一个对象，然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为了实现创造一种新的类型，只是对某个对象实现一种简单继承，ES5 中定义的 `Object.create() `方法就是原型式继承的实现。缺点与原型链方式相同。

5. **寄生式继承** ：寄生式继承的思路是创建一个用于封装继承过程的函数，通过传入一个对象，然后复制一个对象的副本，然后对象进行扩展，最后返回这个对象。这个扩展的过程就可以理解是一种继承。这种继承的优点就是对一个简单对象实现继承，如果这个对象不是我们的自定义类型时。缺点是没有办法实现函数的复用。

6. **寄生式组合继承** ：组合继承的缺点就是使用超类型的实例做为子类型的原型，导致添加了不必要的原型属性。寄生式组合继承的方式是使用超类型的原型的副本来作为子类型的原型，这样就避免了创建不必要的属性。

## 闭包

闭包是指有权访问另一个函数作用域内变量的函数，其实闭包的本质就是作用域链的一个特殊的应用。

## 事件委托

本质上是利用了浏览器事件冒泡的机制。

## 手写 Ajax

```js
function ajax(
  method, 
  url, 
  content = null, 
  headers = { 'Content-Type': 'application/json;charset=UTF-8' }
) {
  const ajax = new XMLHttpRequest();
  return new Promise((resolve, reject) => {
    ajax.onreadystatechange = function() {
      if (ajax.readyState === 4) {
        if (ajax.status === 200) {
          resolve(ajax.responseText);
        } else {
          reject(ajax.status);
        }
      }
    };
    ajax.open(method, url);
    // 设置请求头
    Object.keys(headers).forEach(key => ajax.setRequestHeader(key, headers[key]));
    ajax.send(JSON.stringify(content));
  });
}
//使用方法：
ajax('GET/POST','接口','参数', '请求头').then( res => {
    console.log(res);//获得成功结果
}).catch(err => {
    console.log(err);
})
```

## 延迟加载js

* js置底
* 给 `<script>`  添加 `defer` 属性
* 给 `<script>` 添加 `async` 属性
* 动态创建 `<script>`

## 模块化开发

避免污染

* 命名空间：在一个对象内执行各种操作
* 立即执行函数：局部变量

## js模块规范

1. CommonJS

   它通过 require 来引入模块，通过 `module.exports` 定义模块的输出接口。这种模块加载方案是服务器端的解决方案，它是以同步的方式来引入模块的，因为在服务端文件都存储在本地磁盘，所以读取非常快，所以以同步的方式加载没有问题。但如果是在浏览器端，由于模块的加载是使用网络请求，因此使用异步加载的方式更加合适。

2. AMD

   这种方案采用异步加载的方式来加载模块，模块的加载不影响后面语句的执行，所有依赖这个模块的语句都定义在一个回调函数里，等到加载完成后再执行回调函数。`require.js` 实现了 AMD 规范。

3. CMD

   这种方案和 AMD 方案都是为了解决异步模块加载的问题，`sea.js` 实现了 CMD 规范。它和 `require.js` 的区别在于模块定义时对依赖的处理不同和对依赖模块的执行时机的处理不同

4. `import`/`export`

   ES6 提出的方案，使用 `import` 和 `export` 的形式来导入导出模块。

## AMD 和 CMD 规范的区别
1. **在模块定义时对依赖的处理不同。** AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块。而 CMD 推崇就近依赖，只有在用到某个模块的时候再去 `require`。
2. **对依赖模块的执行时机处理不同。** 首先 AMD 和 CMD 对于模块的加载方式都是异步加载，不过它们的区别在于模块的执行时机，AMD 在依赖模块加载完成后就直接执行依赖模块，依赖模块的执行顺序和我们书写的顺序不一定一致。而 CMD在依赖模块加载完成后并不执行，只是下载而已，等到所有的依赖模块都加载好后，进入回调函数逻辑，遇到 `require` 语句的时候才执行对应的模块，这样模块的执行顺序就和我们书写的顺序保持一致了。

```js
// CMD
define(function(require, exports, module) {
  var a = require("./a");
  a.doSomething();
  // 此处略去 100 行
  var b = require("./b"); // 依赖可以就近书写
  b.doSomething();
  // ...
});

// AMD 默认推荐
define(["./a", "./b"], function(a, b) {
  // 依赖必须一开始就写好
  a.doSomething();
  // 此处略去 100 行
  b.doSomething();
  // ...
});
```

## ES6 模块与 CommonJS 模块、AMD、CMD 的差异。

- 1.CommonJS 模块输出的是一个值的拷贝，**ES6 模块输出的是值的引用**。CommonJS 模块输出的是值的，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令 import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。

- 2.CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。CommonJS 模块就是对象，即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。

## requireJS的核心原理是什么？

通过动态创建 `script` 脚本来异步引入模块，然后对每个脚本的 `load` 事件进行监听，如果每个脚本都加载完成了，再调用回调函数。

## JS的允许机制

### 单线程

同一时间只能做一件事情。

### js事件循环/event loop

主线程 -> 异步任务（微任务 -> 宏任务）

* **微任务** ：包括了 `promise` 的回调、node 中的 `process.nextTick`（所有异步的 **No.1** ） 、对 Dom 变化监听的 `MutationObserver`。 

* **宏任务** ：包括了 script 脚本的执行、`setTimeout` ，`setInterval` ，`setImmediate` 一类的定时事件，还有如 `I/O 操作`、`UI 渲染`等。

* **完整回答** ：

  1. 首先js 是单线程运行的，在代码执行的时候，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行。

  2. 在执行同步代码的时候，如果遇到了异步事件，js 引擎并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务

  3. 当同步事件执行完毕后，再将异步事件对应的回调加入到与当前执行栈中不同的另一个任务队列中等待执行。

  4. 任务队列可以分为宏任务对列和微任务对列，当当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务对列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行。

  5. 当微任务对列中的任务都执行完成后再去判断宏任务对列中的任务。

## arguments 的对象是什么？

伪数组，有 `length`，可以用索引取值。但是没有数组的操作方法，如 `forEach` 等。

一般可以直接用扩张运算符 `...` 、`Array.from()`转换为数组。

## V8 引擎的垃圾回收机制

v8 的垃圾回收机制基于分代回收机制，这个机制又基于世代假说，这个假说有两个特点，一是新生的对象容易早死，另一个是不死的对象会活得更久。基于这个假说，v8 引擎将内存分为了新生代和老生代。

新创建的对象或者只经历过一次的垃圾回收的对象被称为新生代。经历过多次垃圾回收的对象被称为老生代。

新生代被分为 From 和 To 两个空间，To 一般是闲置的。当 From 空间满了的时候会执行 Scavenge 算法进行垃圾回收。当我们执行垃圾回收算法的时候应用逻辑将会停止，等垃圾回收结束后再继续执行。这个算法分为三步：

（1）首先检查 From 空间的存活对象，如果对象存活则判断对象是否满足晋升到老生代的条件，如果满足条件则晋升到老生代。如果不满足条件则移动 To 空间。

（2）如果对象不存活，则释放对象的空间。

（3）最后将 From 空间和 To 空间角色进行交换。

新生代对象晋升到老生代有两个条件：

（1）第一个是判断是对象否已经经过一次 Scavenge 回收。若经历过，则将对象从 From 空间复制到老生代中；若没有经历，则复制到 To 空间。

（2）第二个是 To 空间的内存使用占比是否超过限制。当对象从 From 空间复制到 To 空间时，若 To 空间使用超过 25%，则对象直接晋升到老生代中。设置 25% 的原因主要是因为算法结束后，两个空间结束后会交换位置，如果 To 空间的内存太小，会影响后续的内存分配。

老生代采用了标记清除法和标记压缩法。标记清除法首先会对内存中存活的对象进行标记，标记结束后清除掉那些没有标记的对象。由于标记清除后会造成很多的内存碎片，不便于后面的内存分配。所以了解决内存碎片的问题引入了标记压缩法。

由于在进行垃圾回收的时候会暂停应用的逻辑，对于新生代方法由于内存小，每次停顿的时间不会太长，但对于老生代来说每次垃圾回收的时间长，停顿会造成很大的影响。 为了解决这个问题 V8 引入了增量标记的方法，将一次停顿进行的过程分为了多步，每次执行完一小步就让运行逻辑执行一会，就这样交替运行。

## 哪些操作会造成内存泄漏？

* 意外的全局变量
  由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。
* 被遗忘的计时器或回调函数
  设置了`setInterval`定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。
* 脱离 DOM 的引用
  获取一个DOM元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收。
* 闭包
  不合理的使用闭包，从而导致某些变量一直被留在内存当中。

## `var` , `let` 和 `const` 的区别是什么？

1. `var` 声明的变量会挂载在 `window` 上，而 `let` 和 `const` 声明的变量不会：

2. `var` 声明变量存在变量提升， `let` 和 `const` 不存在变量提升:

3. `let` 和 `const` 声明形成块作用域

4. 同一作用域下 `let` 和 `const` 不能声明同名变量，而var可以

5. 暂存死区
    ```js
    var a = 100;

    if (1) {
      a = 10;
      //在当前块作用域中存在a使用let/const声明的情况下，给a赋值10时，只会在当前作用域找变量a，
      // 而这时，还未到声明时候，所以控制台Error:a is not defined
      let a = 1;
    }
    ```
    
6. `const`

    * 声明必须赋值
    * 引用类型指针不可改变
    * 基本类型不可变


## 声明变量的方式

ES5 只有两种声明变量的方法：`var` 命令和 `function` 命令。ES6 除了添加 `let` 和 `const` 命令，后面章节还会提到，另外两种声明变量的方法： `import` 命令和 `class` 命令。所以，ES6 一共有 6 种声明变量的方法。

所以：`var`、`function`、`let`、`const`、`import`、`class`

## 箭头函数的作用域

箭头函数没有自己的this值。它捕获词法作用域函数的 `this` 值。

## 什么是 class`

类(`class`)是在 JS 中编写构造函数的新方法。它是使用构造函数的语法糖，在底层中使用仍然是原型和基于原型的继承。

## `Set` 对象

`Set` 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。

常用场景，去重：`[...new Set(yourArr)]`

## 手写 `call`、 `apply` 、`bind` 函数

三个设定函数作用域的方法，大致都差不多，以`call` 为例：

1. 判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 `call` 等方式调用的情况。
2. 判断传入上下文对象是否存在，如果不存在，则设置为 `window` 。
3. 处理传入的参数，截取第一个参数后的所有参数。
4. 将函数作为上下文对象的一个属性。
5. 使用上下文对象来调用这个方法，并保存返回结果。
6. 删除刚才新增的属性。
7. 返回结果。

```js
// call 的实现
Function.prototype.myCall = function(context, ...args) {
  if (typeof this !== 'function') {
    console.error('type error');
  }
  // 如果未传入 context ，则使用 window
  context = context || window;

  // 随便起一个不会撞车的 key 值，并将其 value 设定为改函数，即 this；
  const fnKey = Symbol('fn');
  context[fnKey] = this;

  // 执行
  const res = context[fnKey](...args);

  // 移除刚刚设定的 key
  delete context[fnKey];

  // 返回执行结果
  return res;
}

// apply 的实现
Function.prototype.myApply = function(context, args = []) {
  if (typeof this !== 'function') {
    console.error('type error');
  }
  context = context || window;
  const fnKey = Symbol('fn');
  context[fnKey] = this;
  const res = context[fnKey](...args);
  delete context[fnKey];
  return res;
}

// bind 的实现
Function.prototype.myBind = function(context, ...args) {
  // 需要注意：
  // 不执行函数，返回绑定了 context 的函数。
  // 参数拼接
  const fn = (...args2) => {
    if (typeof this !== 'function') {
      console.error('type error');
    }
    context = context || window;
    const fnKey = Symbol('fn');
    context[fnKey] = this;
    const res = context[fnKey](...args, ...args2);
    delete context[fnKey];
    return res;
    // 直接使用 call/apply
    // return this.call(context, ...args, ...args2);
    // return this.apply(context, [...args, ...args2]);
  }
  return fn;
}
```

## 手写 `new` 操作符

`new` 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。`new` 关键字会进行如下的操作：

1. 创建一个空的简单JavaScript对象；
2. 链接该对象（即设置该对象的构造函数）到另一个对象 ；
3. 将步骤1新创建的对象作为 `this` 的上下文 ；
4. 如果该函数没有返回对象，则返回 `this`。

```js
function myNew(fn, ...args) {
  const obj = Object.create(fn.prototype);
  const result = fn.call(obj, ...args);
  return typeof result === 'object' ? result || obj : obj;
}
```

## `Iterator` 是什么，有什么用？

> ES6为了提供的类似其他语言的 `for...of` 接口,其作用是遍历任何对象。于是设计了任何对象只要有`Symbol.iterator`属性，就是可遍历的。

`Iterator`（迭代器）是一种接口，也可以说是一种规范。为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署`Iterator`接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。

`[Symbol.iterator]` 属性名是固定的写法，只要拥有了该属性的对象，就能够用迭代器的方式进行遍历。

迭代器的遍历方法是首先获得一个迭代器的指针，初始时该指针指向第一条数据之前，接着通过调用 `next` 方法，改变指针的指向，让其指向下一条数据 每一次的 `next` 都会返回一个对象，该对象有两个属性

- `value` 代表想要获取的数据
- `done` 布尔值，`false` 表示当前指针指向的数据有值，`true` 表示遍历已经结束

**Iterator 的作用有三个：**

1. 为各种数据结构，提供一个统一的、简便的访问接口；
2. 使得数据结构的成员能够按某种次序排列；
3. ES6 创造了一种新的遍历命令for…of循环，Iterator 接口主要供for…of消费。

**遍历过程：**

1. 创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。
2. 第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。
3. 第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。
4. 不断调用指针对象的next方法，直到它指向数据结构的结束位置。

**原生具备 Iterator 接口的数据结构如下：**

- Array
- Map
- Set
- String
- TypedArray
- 函数的 arguments 对象
- NodeList 对象

## `Generator` 是什么？有什么用？

`Generator` 函数可以说是 `Iterator` 接口的具体实现方式。 `Generator` 最大的特点就是可以控制函数的执行。

```js
function *foo(x) {
  let y = 2 * (yield (x + 1))
  let z = yield (y / 3)
  return (x + y + z)
}
let it = foo(5)
console.log(it.next())   // => {value: 6, done: false}
console.log(it.next(12)) // => {value: 8, done: false}
console.log(it.next(13)) // => {value: 42, done: true}
```

## async/await 优缺点

`async/await`的优势在于处理 `then` 的调用链，能够更清晰准确的写出代码，并且也能优雅地解决回调地狱问题。当然也存在一些缺点，因为 `await` 将异步代码改造成了同步代码，如果多个异步代码没有依赖性却使用了 `await` 会导致性能上的降低。

需要注意，只要加上了 `async` 的函数，无论返回什么都会变成 `Promise`，（比如返回`3`，则转换为`Promise.resolve(3)` 。若返回自身就是 `Promise` 则直接返回自身）。

## instanceof的原理是什么，如何实现

`instanceof` 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 `prototype`。

实现 `instanceof`：

1. 首先获取类型的原型
2. 然后获得对象的原型
3. 然后一直循环判断对象的原型是否等于类型的原型，直到对象原型为 `null`，因为原型链最终为 `null`

```js
function myInstanceof(left, right) {
  let prototype = right.prototype
  left = left.__proto__
  while (true) {
    if (left === null || left === undefined)
      return false
    if (prototype === left)
      return true
    left = left.__proto__
  }
}
```

## 防抖、节流简易版

```js
// 函数防抖的实现
function debounce(fn, wait) {
  var timer = null;

  return function() {
    var context = this,
      args = arguments;

    // 如果此时存在定时器的话，则取消之前的定时器重新记时
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }

    // 设置定时器，使事件间隔指定事件后执行
    timer = setTimeout(() => {
      fn.apply(context, args);
    }, wait);
  };
}

// 函数节流的实现;
function throttle(fn, delay) {
  var preTime = Date.now();

  return function() {
    var context = this,
      args = arguments,
      nowTime = Date.now();

    // 如果两次时间间隔超过了指定时间，则执行函数。
    if (nowTime - preTime >= delay) {
      preTime = Date.now();
      return fn.apply(context, args);
    }
  };
}
```

## 什么是设计模式

设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。

## 五个设计原则

**S – Single Responsibility Principle 单一职责原则**

- 一个程序只做好一件事
- 如果功能过于复杂就拆分开，每个部分保持独立

**O – OpenClosed Principle 开放/封闭原则**

- 对扩展开放，对修改封闭
- 增加需求时，扩展新代码，而非修改已有代码

**L – Liskov Substitution Principle 里氏替换原则**

- 子类能覆盖父类
- 父类能出现的地方子类就能出现

**I – Interface Segregation Principle 接口隔离原则**

- 保持接口的单一独立
- 类似单一职责原则，这里更关注接口

**D – Dependency Inversion Principle 依赖倒转原则**

- 面向接口编程，依赖于抽象而不依赖于具
- 使用方只关注接口而不关注具体类的实现

## 三种设计模式类型

**结构型模式（Structural Patterns）：** 通过识别系统中组件间的简单关系来简化系统的设计。

**创建型模式（Creational Patterns）：** 处理对象的创建，根据实际情况使用合适的方式创建对象。常规的对象创建方式可能会导致设计上的问题，或增加设计的复杂度。创建型模式通过以某种方式控制对象的创建来解决问题。

**行为型模式（Behavioral Patterns）：** 用于识别对象之间常见的交互模式并加以实现，如此，增加了这些交互的灵活性。

## 9种前端常见的设计模式

#### 1. 外观模式（Facade Pattern）

提供简单易用的API

缺点：不符合开闭原则，改起来麻烦。

#### 2. 代理模式（Proxy Pattern）

不直接修改，找个中间商代理，由中间商保护目标。

缺点：加了层代理，会有额外开销。

#### 3. 工厂模式（Factory Pattern）

实例化对象是，由厂家去控制实例化成哪个对象。我们只需关注结果即可。

缺点：添加新构造函数时复杂度高了点。

#### 4. 单例模式（Singleton Pattern）

只 `new` 一个对象出来用，比如在 `Vue 2.x` 就是这样。

缺点：耦合度高、不太好单元测试

#### 4. 单例模式（Singleton Pattern）

#### 5. 策略模式（Strategy Pattern）

写个战术，以分别使用不同函数/参数。

```js
// 非策略模式，硬写
if (普通用户) {
    普通用户操作()
} else if (会员用户) {
    会员用户操作()
}
// 策略模式
const 我的策略 = {
    普通用户: 普通用户操作
    会员用户: 会员用户操作
}
我的策略[xx用户]();

```

缺点：函数可能会有点多

#### 6. 迭代器模式（Iterator Pattern）

提供一种方法顺序一个聚合对象中各个元素

#### 7. 观察者模式（Observer Pattern）

**观察者模式**又称**发布-订阅模式**（Publish/Subscribe Pattern）

**被观察对象（subject）维护一组观察者（observer），当被观察对象状态改变时，通过调用观察者的某个方法将这些变化通知到观察者**。

缺点：过度使用会导致对象与对象之间的联系弱化（比如数据和 `DOM` ，还好 `Vue` 够优秀）

#### 8. 中介者模式（Mediator Pattern）

对象直接不直接沟通，通过中介。

缺点：复杂度高的话，导致中介会及其复杂

#### 9. 访问者模式（Visitor Pattern）

不影响自身的前提下，可以随便提供其他逻辑，即添加插件。扩展好。

缺点：插件多了后果你知道的。